/* tslint:disable */
/* eslint-disable */
/**
 * Invoice Ninja
 * Invoice Ninja. Open Source Invoicing lives here.
 *
 * The version of the OpenAPI document: 5.3
 * Contact: contact@invoiceninja.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   * The account hashed id
   * @type {string}
   * @memberof Account
   */
  id?: string;
}
/**
 *
 * @export
 * @interface Activity
 */
export interface Activity {
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  activity_type_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  client_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  company_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  user_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  invoice_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  payment_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  credit_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  updated_at?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  expense_id?: string;
  /**
   * ______
   * @type {boolean}
   * @memberof Activity
   */
  is_system?: boolean;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  contact_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  task_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  notes?: string;
  /**
   * ______
   * @type {string}
   * @memberof Activity
   */
  ip?: string;
}
/**
 *
 * @export
 * @interface Client
 */
export interface Client {
  /**
   * _________
   * @type {string}
   * @memberof Client
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Client
   */
  user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  company_id?: string;
  /**
   *
   * @type {Array<ClientContact>}
   * @memberof Client
   */
  contacts?: Array<ClientContact>;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  name?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  website?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  private_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  client_hash?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  industry_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  size_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  address1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  address2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  city?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  state?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  postal_code?: string;
  /**
   * The client phone number
   * @type {string}
   * @memberof Client
   */
  phone?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  country_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  vat_number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  id_number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  shipping_address1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  shipping_address2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  shipping_city?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  shipping_state?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  shipping_postal_code?: string;
  /**
   * ________
   * @type {string}
   * @memberof Client
   */
  shipping_country_id?: string;
  /**
   * ________
   * @type {boolean}
   * @memberof Client
   */
  is_deleted?: boolean;
  /**
   * ________
   * @type {number}
   * @memberof Client
   */
  balance?: number;
  /**
   * ________
   * @type {number}
   * @memberof Client
   */
  paid_to_date?: number;
  /**
   * An amount which is available to the client for future use.
   * @type {number}
   * @memberof Client
   */
  credit_balance?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Client
   */
  last_login?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Client
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Client
   */
  updated_at?: number;
  /**
   *
   * @type {CompanySettings}
   * @memberof Client
   */
  settings?: CompanySettings;
}
/**
 *
 * @export
 * @interface ClientContact
 */
export interface ClientContact {
  /**
   * _________
   * @type {string}
   * @memberof ClientContact
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof ClientContact
   */
  user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  client_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  first_name?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  last_name?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  phone?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  email?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  accepted_terms_version?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  password?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  confirmation_code?: string;
  /**
   * ________
   * @type {string}
   * @memberof ClientContact
   */
  token?: string;
  /**
   * ________
   * @type {boolean}
   * @memberof ClientContact
   */
  is_primary?: boolean;
  /**
   * ________
   * @type {boolean}
   * @memberof ClientContact
   */
  confirmed?: boolean;
  /**
   * ________
   * @type {boolean}
   * @memberof ClientContact
   */
  is_locked?: boolean;
  /**
   * ________
   * @type {boolean}
   * @memberof ClientContact
   */
  send_email?: boolean;
  /**
   * ________
   * @type {number}
   * @memberof ClientContact
   */
  failed_logins?: number;
  /**
   * ________
   * @type {number}
   * @memberof ClientContact
   */
  email_verified_at?: number;
  /**
   * ________
   * @type {number}
   * @memberof ClientContact
   */
  paid_to_date?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof ClientContact
   */
  last_login?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof ClientContact
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof ClientContact
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof ClientContact
   */
  deleted_at?: number;
}
/**
 *
 * @export
 * @interface ClientGatewayToken
 */
export interface ClientGatewayToken {
  /**
   * ______
   * @type {string}
   * @memberof ClientGatewayToken
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof ClientGatewayToken
   */
  company_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof ClientGatewayToken
   */
  client_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof ClientGatewayToken
   */
  token?: string;
  /**
   * ______
   * @type {string}
   * @memberof ClientGatewayToken
   */
  routing_number?: string;
  /**
   * ______
   * @type {string}
   * @memberof ClientGatewayToken
   */
  company_gateway_id?: string;
  /**
   * ______
   * @type {boolean}
   * @memberof ClientGatewayToken
   */
  is_default?: boolean;
}
/**
 *
 * @export
 * @interface Company
 */
export interface Company {
  /**
   * The company hash id
   * @type {string}
   * @memberof Company
   */
  id?: string;
  /**
   * The company size ID
   * @type {string}
   * @memberof Company
   */
  size_id?: string;
  /**
   * The company industry ID
   * @type {string}
   * @memberof Company
   */
  industry_id?: string;
  /**
   * The slack webhook notification URL
   * @type {string}
   * @memberof Company
   */
  slack_webhook_url?: string;
  /**
   * The google analytics key
   * @type {string}
   * @memberof Company
   */
  google_analytics_key?: string;
  /**
   * Determines the client facing urls ie: subdomain,domain,iframe
   * @type {string}
   * @memberof Company
   */
  portal_mode?: string;
  /**
   * Specifies the first part of the company domain ie acme in acme.domain.com
   * @type {string}
   * @memberof Company
   */
  subdomain?: string;
  /**
   * The fully qualified domain for client facing URLS
   * @type {string}
   * @memberof Company
   */
  portal_domain?: string;
  /**
   * Number of taxes rates used per entity
   * @type {number}
   * @memberof Company
   */
  enabled_tax_rates?: number;
  /**
   * Toggles filling a product description based on product key
   * @type {boolean}
   * @memberof Company
   */
  fill_products?: boolean;
  /**
   * ___________
   * @type {boolean}
   * @memberof Company
   */
  convert_products?: boolean;
  /**
   * Toggles updating a product description which description changes
   * @type {boolean}
   * @memberof Company
   */
  update_products?: boolean;
  /**
   * Toggles showing a product description which description changes
   * @type {boolean}
   * @memberof Company
   */
  show_product_details?: boolean;
  /**
   * Custom fields map
   * @type {object}
   * @memberof Company
   */
  custom_fields?: object;
  /**
   * ______________
   * @type {boolean}
   * @memberof Company
   */
  enable_product_cost?: boolean;
  /**
   * ______________
   * @type {boolean}
   * @memberof Company
   */
  enable_product_quantity?: boolean;
  /**
   * ______________
   * @type {boolean}
   * @memberof Company
   */
  default_quantity?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Company
   */
  custom_surcharge_taxes1?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Company
   */
  custom_surcharge_taxes2?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Company
   */
  custom_surcharge_taxes3?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Company
   */
  custom_surcharge_taxes4?: boolean;
  /**
   * The company logo - binary
   * @type {object}
   * @memberof Company
   */
  logo?: object;
  /**
   *
   * @type {CompanySettings}
   * @memberof Company
   */
  settings?: CompanySettings;
}
/**
 *
 * @export
 * @interface CompanyGateway
 */
export interface CompanyGateway {
  /**
   * ______
   * @type {string}
   * @memberof CompanyGateway
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof CompanyGateway
   */
  company_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof CompanyGateway
   */
  gateway_key?: string;
  /**
   * Bitmask representation of cards
   * @type {number}
   * @memberof CompanyGateway
   */
  accepted_credit_cards?: number;
  /**
   * ______
   * @type {boolean}
   * @memberof CompanyGateway
   */
  require_billing_address?: boolean;
  /**
   * ______
   * @type {boolean}
   * @memberof CompanyGateway
   */
  require_shipping_address?: boolean;
  /**
   * The configuration map for the gateway
   * @type {string}
   * @memberof CompanyGateway
   */
  config?: string;
  /**
   * ______
   * @type {boolean}
   * @memberof CompanyGateway
   */
  update_details?: boolean;
  /**
   * A mapped collection of the fees and limits for the configured gateway
   * @type {Array<FeesAndLimits>}
   * @memberof CompanyGateway
   */
  fees_and_limits?: Array<FeesAndLimits>;
}
/**
 *
 * @export
 * @interface CompanyLedger
 */
export interface CompanyLedger {
  /**
   * This field will reference one of the following entity hashed ID payment_id, invoice_id or credit_id
   * @type {string}
   * @memberof CompanyLedger
   */
  entity_id?: string;
  /**
   * The notes which reference this entry of the ledger
   * @type {string}
   * @memberof CompanyLedger
   */
  notes?: string;
  /**
   * The client balance
   * @type {number}
   * @memberof CompanyLedger
   */
  balance?: number;
  /**
   * The amount the client balance is adjusted by
   * @type {number}
   * @memberof CompanyLedger
   */
  adjustment?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof CompanyLedger
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof CompanyLedger
   */
  created_at?: number;
}
/**
 *
 * @export
 * @interface CompanySettings
 */
export interface CompanySettings {
  /**
   * The timezone id
   * @type {string}
   * @memberof CompanySettings
   */
  timezone_id?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  date_format_id?: string;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  military_time?: boolean;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  language_id?: string;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  show_currency_code?: boolean;
  /**
   * The default currency id
   * @type {string}
   * @memberof CompanySettings
   */
  currency_id?: string;
  /**
   * -1 sets no payment term, 0 sets payment due immediately, positive integers indicates payment terms in days
   * @type {number}
   * @memberof CompanySettings
   */
  payment_terms?: number;
  /**
   * A commad separate list of available gateways
   * @type {string}
   * @memberof CompanySettings
   */
  company_gateway_ids?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_value1?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_value2?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_value3?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_value4?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  default_task_rate?: number;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  send_reminders?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_client_portal_tasks?: boolean;
  /**
   * options include plain,light,dark,custom
   * @type {string}
   * @memberof CompanySettings
   */
  email_style?: string;
  /**
   * The reply to email address
   * @type {string}
   * @memberof CompanySettings
   */
  reply_to_email?: string;
  /**
   * A comma separate list of BCC emails
   * @type {string}
   * @memberof CompanySettings
   */
  bcc_email?: string;
  /**
   * Toggles whether to attach PDF as attachment
   * @type {boolean}
   * @memberof CompanySettings
   */
  pdf_email_attachment?: boolean;
  /**
   * Toggles whether to attach UBL as attachment
   * @type {boolean}
   * @memberof CompanySettings
   */
  ubl_email_attachment?: boolean;
  /**
   * The custom template
   * @type {string}
   * @memberof CompanySettings
   */
  email_style_custom?: string;
  /**
   * enum when the invoice number counter is set, ie when_saved, when_sent, when_paid
   * @type {string}
   * @memberof CompanySettings
   */
  counter_number_applied?: string;
  /**
   * enum when the quote number counter is set, ie when_saved, when_sent
   * @type {string}
   * @memberof CompanySettings
   */
  quote_number_applied?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_message_dashboard?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_message_unpaid_invoice?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_message_paid_invoice?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  custom_message_unapproved_quote?: string;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  lock_invoices?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  auto_archive_invoice?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  auto_archive_quote?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  auto_convert_quote?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  inclusive_taxes?: boolean;
  /**
   * JSON payload of customized translations
   * @type {object}
   * @memberof CompanySettings
   */
  translations?: object;
  /**
   * Allows customisation of the task number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  task_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  task_number_counter?: number;
  /**
   * Time from UTC +0 when the email will be sent to the client
   * @type {number}
   * @memberof CompanySettings
   */
  reminder_send_time?: number;
  /**
   * Allows customisation of the expense number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  expense_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  expense_number_counter?: number;
  /**
   * Allows customisation of the vendor number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  vendor_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  vendor_number_counter?: number;
  /**
   * Allows customisation of the ticket number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  ticket_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  ticket_number_counter?: number;
  /**
   * Allows customisation of the payment number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  payment_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  payment_number_counter?: number;
  /**
   * Allows customisation of the invoice number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  invoice_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  invoice_number_counter?: number;
  /**
   * Allows customisation of the quote number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  quote_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  quote_number_counter?: number;
  /**
   * Allows customisation of the client number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  client_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  client_number_counter?: number;
  /**
   * Allows customisation of the credit number pattern
   * @type {string}
   * @memberof CompanySettings
   */
  credit_number_pattern?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  credit_number_counter?: number;
  /**
   * This string is prepended to the recurring invoice number
   * @type {string}
   * @memberof CompanySettings
   */
  recurring_invoice_number_prefix?: string;
  /**
   * CONSTANT which is used to apply the frequency which the counters are reset
   * @type {number}
   * @memberof CompanySettings
   */
  reset_counter_frequency_id?: number;
  /**
   * The explicit date which is used to reset counters
   * @type {string}
   * @memberof CompanySettings
   */
  reset_counter_date?: string;
  /**
   * Pads the counter with leading zeros
   * @type {number}
   * @memberof CompanySettings
   */
  counter_padding?: number;
  /**
   * Flags whether to share the counter for invoices and quotes
   * @type {boolean}
   * @memberof CompanySettings
   */
  shared_invoice_quote_counter?: boolean;
  /**
   * Determines if client fields are updated from third party APIs
   * @type {boolean}
   * @memberof CompanySettings
   */
  update_products?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CompanySettings
   */
  convert_products?: boolean;
  /**
   * Automatically fill products based on product_key
   * @type {boolean}
   * @memberof CompanySettings
   */
  fill_products?: boolean;
  /**
   * The default invoice terms
   * @type {string}
   * @memberof CompanySettings
   */
  invoice_terms?: string;
  /**
   * The default quote terms
   * @type {string}
   * @memberof CompanySettings
   */
  quote_terms?: string;
  /**
   * Taxes can be applied to the invoice
   * @type {number}
   * @memberof CompanySettings
   */
  invoice_taxes?: number;
  /**
   * The default design id (invoice, quote etc)
   * @type {string}
   * @memberof CompanySettings
   */
  invoice_design_id?: string;
  /**
   * The default design id (invoice, quote etc)
   * @type {string}
   * @memberof CompanySettings
   */
  quote_design_id?: string;
  /**
   * The default invoice footer
   * @type {string}
   * @memberof CompanySettings
   */
  invoice_footer?: string;
  /**
   * JSON string of invoice labels
   * @type {string}
   * @memberof CompanySettings
   */
  invoice_labels?: string;
  /**
   * The tax rate (float)
   * @type {number}
   * @memberof CompanySettings
   */
  tax_rate1?: number;
  /**
   * The tax name
   * @type {string}
   * @memberof CompanySettings
   */
  tax_name1?: string;
  /**
   * The tax rate (float)
   * @type {number}
   * @memberof CompanySettings
   */
  tax_rate2?: number;
  /**
   * The tax name
   * @type {string}
   * @memberof CompanySettings
   */
  tax_name2?: string;
  /**
   * The tax rate (float)
   * @type {number}
   * @memberof CompanySettings
   */
  tax_rate3?: number;
  /**
   * The tax name
   * @type {string}
   * @memberof CompanySettings
   */
  tax_name3?: string;
  /**
   * The default payment type id
   * @type {string}
   * @memberof CompanySettings
   */
  payment_type_id?: string;
  /**
   * JSON string of custom fields
   * @type {string}
   * @memberof CompanySettings
   */
  custom_fields?: string;
  /**
   * The default email footer
   * @type {string}
   * @memberof CompanySettings
   */
  email_footer?: string;
  /**
   * The email driver to use to send email, options include default, gmail
   * @type {string}
   * @memberof CompanySettings
   */
  email_sending_method?: string;
  /**
   * The hashed_id of the user account to send email from
   * @type {string}
   * @memberof CompanySettings
   */
  gmail_sending_user_id?: string;
  /**
   *
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_invoice?: string;
  /**
   *
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_quote?: string;
  /**
   *
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_payment?: string;
  /**
   * The full template for invoice emails
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_invoice?: string;
  /**
   * The full template for quote emails
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_quote?: string;
  /**
   * The full template for payment emails
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_payment?: string;
  /**
   * Email subject for Reminder
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_reminder1?: string;
  /**
   * Email subject for Reminder
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_reminder2?: string;
  /**
   * Email subject for Reminder
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_reminder3?: string;
  /**
   * Email subject for endless reminders
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_reminder_endless?: string;
  /**
   * The full template for Reminder 1
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_reminder1?: string;
  /**
   * The full template for Reminder 2
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_reminder2?: string;
  /**
   * The full template for Reminder 3
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_reminder3?: string;
  /**
   * The full template for enless reminders
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_reminder_endless?: string;
  /**
   * Toggles whether a password is required to log into the client portal
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_portal_password?: boolean;
  /**
   * Toggles whether the terms dialogue is shown to the client
   * @type {boolean}
   * @memberof CompanySettings
   */
  show_accept_invoice_terms?: boolean;
  /**
   * Toggles whether the terms dialogue is shown to the client
   * @type {boolean}
   * @memberof CompanySettings
   */
  show_accept_quote_terms?: boolean;
  /**
   * Toggles whether a invoice signature is required
   * @type {boolean}
   * @memberof CompanySettings
   */
  require_invoice_signature?: boolean;
  /**
   * Toggles whether a quote signature is required
   * @type {boolean}
   * @memberof CompanySettings
   */
  require_quote_signature?: boolean;
  /**
   * The company name
   * @type {string}
   * @memberof CompanySettings
   */
  name?: string;
  /**
   * The company logo file
   * @type {object}
   * @memberof CompanySettings
   */
  company_logo?: object;
  /**
   * The company website URL
   * @type {string}
   * @memberof CompanySettings
   */
  website?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  address1?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  address2?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  city?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  state?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  postal_code?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  phone?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email?: string;
  /**
   * The country ID
   * @type {string}
   * @memberof CompanySettings
   */
  country_id?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  vat_number?: string;
  /**
   * The default page size
   * @type {string}
   * @memberof CompanySettings
   */
  page_size?: string;
  /**
   * The font size
   * @type {number}
   * @memberof CompanySettings
   */
  font_size?: number;
  /**
   * The primary font
   * @type {string}
   * @memberof CompanySettings
   */
  primary_font?: string;
  /**
   * The secondary font
   * @type {string}
   * @memberof CompanySettings
   */
  secondary_font?: string;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  hide_paid_to_date?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  embed_documents?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  all_pages_header?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  all_pages_footer?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  document_email_attachment?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_client_portal_password?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_email_markup?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_client_portal_dashboard?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_client_portal?: boolean;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_statement?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_statement?: string;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  signature_on_pdf?: boolean;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  quote_footer?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_custom1?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_custom2?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_subject_custom3?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_custom1?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_custom2?: string;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  email_template_custom3?: string;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_reminder1?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_reminder2?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  enable_reminder3?: boolean;
  /**
   * The Reminder interval
   * @type {number}
   * @memberof CompanySettings
   */
  num_days_reminder1?: number;
  /**
   * The Reminder interval
   * @type {number}
   * @memberof CompanySettings
   */
  num_days_reminder2?: number;
  /**
   * The Reminder interval
   * @type {number}
   * @memberof CompanySettings
   */
  num_days_reminder3?: number;
  /**
   * (enum: after_invoice_date, before_due_date, after_due_date)
   * @type {string}
   * @memberof CompanySettings
   */
  schedule_reminder1?: string;
  /**
   * (enum: after_invoice_date, before_due_date, after_due_date)
   * @type {string}
   * @memberof CompanySettings
   */
  schedule_reminder2?: string;
  /**
   * (enum: after_invoice_date, before_due_date, after_due_date)
   * @type {string}
   * @memberof CompanySettings
   */
  schedule_reminder3?: string;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  late_fee_amount1?: number;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  late_fee_amount2?: number;
  /**
   * ____________
   * @type {number}
   * @memberof CompanySettings
   */
  late_fee_amount3?: number;
  /**
   * ____________
   * @type {string}
   * @memberof CompanySettings
   */
  endless_reminder_frequency_id?: string;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  client_online_payment_notification?: boolean;
  /**
   * ____________
   * @type {boolean}
   * @memberof CompanySettings
   */
  client_manual_payment_notification?: boolean;
}
/**
 *
 * @export
 * @interface CompanyToken
 */
export interface CompanyToken {
  /**
   * The token name
   * @type {string}
   * @memberof CompanyToken
   */
  name?: string;
  /**
   * The token value
   * @type {string}
   * @memberof CompanyToken
   */
  token?: string;
  /**
   * Determines whether the token is created by the system rather than a user
   * @type {boolean}
   * @memberof CompanyToken
   */
  is_system?: boolean;
}
/**
 *
 * @export
 * @interface CompanyUser
 */
export interface CompanyUser {
  /**
   * The company user permissions
   * @type {string}
   * @memberof CompanyUser
   */
  permissions?: string;
  /**
   * The company name
   * @type {object}
   * @memberof CompanyUser
   */
  settings?: object;
  /**
   * Determines whether the user owns this company
   * @type {boolean}
   * @memberof CompanyUser
   */
  is_owner?: boolean;
  /**
   * Determines whether the user is the admin of this company
   * @type {boolean}
   * @memberof CompanyUser
   */
  is_admin?: boolean;
  /**
   * Determines whether the users access to this company has been locked
   * @type {boolean}
   * @memberof CompanyUser
   */
  is_locked?: boolean;
  /**
   * The last time the record was modified
   * @type {number}
   * @memberof CompanyUser
   */
  updated_at?: number;
  /**
   * Timestamp when the user was archived
   * @type {number}
   * @memberof CompanyUser
   */
  deleted_at?: number;
  /**
   *
   * @type {Account}
   * @memberof CompanyUser
   */
  account?: Account;
  /**
   *
   * @type {Company}
   * @memberof CompanyUser
   */
  company?: Company;
  /**
   *
   * @type {User}
   * @memberof CompanyUser
   */
  user?: User;
  /**
   *
   * @type {CompanyToken}
   * @memberof CompanyUser
   */
  token?: CompanyToken;
}
/**
 *
 * @export
 * @interface Credit
 */
export interface Credit {
  /**
   * _________
   * @type {string}
   * @memberof Credit
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Credit
   */
  user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Credit
   */
  assigned_user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  client_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  status_id?: string;
  /**
   * The linked invoice this credit is applied to
   * @type {string}
   * @memberof Credit
   */
  invoice_id?: string;
  /**
   * The credit number - is a unique alpha numeric number per credit per company
   * @type {string}
   * @memberof Credit
   */
  number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  po_number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  terms?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  public_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  private_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  footer?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  tax_name1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  tax_name2?: string;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  tax_rate1?: number;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  tax_rate2?: number;
  /**
   * ________
   * @type {string}
   * @memberof Credit
   */
  tax_name3?: string;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  tax_rate3?: number;
  /**
   * The total taxes for the credit
   * @type {number}
   * @memberof Credit
   */
  total_taxes?: number;
  /**
   * _________
   * @type {object}
   * @memberof Credit
   */
  line_items?: object;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  amount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  balance?: number;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  paid_to_date?: number;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  discount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Credit
   */
  partial?: number;
  /**
   * _________
   * @type {boolean}
   * @memberof Credit
   */
  is_amount_discount?: boolean;
  /**
   * _________
   * @type {boolean}
   * @memberof Credit
   */
  is_deleted?: boolean;
  /**
   * Defines the type of taxes used as either inclusive or exclusive
   * @type {boolean}
   * @memberof Credit
   */
  uses_inclusive_taxes?: boolean;
  /**
   * The Credit Date
   * @type {string}
   * @memberof Credit
   */
  date?: string;
  /**
   * The last date the credit was sent out
   * @type {string}
   * @memberof Credit
   */
  last_sent_date?: string;
  /**
   * The Next date for a reminder to be sent
   * @type {string}
   * @memberof Credit
   */
  next_send_date?: string;
  /**
   * _________
   * @type {string}
   * @memberof Credit
   */
  partial_due_date?: string;
  /**
   * _________
   * @type {string}
   * @memberof Credit
   */
  due_date?: string;
  /**
   *
   * @type {CompanySettings}
   * @memberof Credit
   */
  settings?: CompanySettings;
  /**
   * Timestamp
   * @type {number}
   * @memberof Credit
   */
  last_viewed?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Credit
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Credit
   */
  archived_at?: number;
  /**
   * First Custom Surcharge
   * @type {number}
   * @memberof Credit
   */
  custom_surcharge1?: number;
  /**
   * Second Custom Surcharge
   * @type {number}
   * @memberof Credit
   */
  custom_surcharge2?: number;
  /**
   * Third Custom Surcharge
   * @type {number}
   * @memberof Credit
   */
  custom_surcharge3?: number;
  /**
   * Fourth Custom Surcharge
   * @type {number}
   * @memberof Credit
   */
  custom_surcharge4?: number;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Credit
   */
  custom_surcharge_tax1?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Credit
   */
  custom_surcharge_tax2?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Credit
   */
  custom_surcharge_tax3?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Credit
   */
  custom_surcharge_tax4?: boolean;
}
/**
 *
 * @export
 * @interface CreditPaymentable
 */
export interface CreditPaymentable {
  /**
   * ______
   * @type {string}
   * @memberof CreditPaymentable
   */
  credit_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof CreditPaymentable
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface Design
 */
export interface Design {
  /**
   * The design hashed id
   * @type {string}
   * @memberof Design
   */
  id?: string;
  /**
   * The design name
   * @type {string}
   * @memberof Design
   */
  name?: string;
  /**
   * The design HTML
   * @type {string}
   * @memberof Design
   */
  design?: string;
  /**
   * Flag to determine if the design is a custom user design
   * @type {boolean}
   * @memberof Design
   */
  is_custom?: boolean;
  /**
   * Flag to determine if the design is available for use
   * @type {boolean}
   * @memberof Design
   */
  is_active?: boolean;
  /**
   * Flag to determine if the design is deleted
   * @type {boolean}
   * @memberof Design
   */
  is_deleted?: boolean;
  /**
   * Timestamp
   * @type {number}
   * @memberof Design
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Design
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Design
   */
  deleted_at?: number;
}
/**
 *
 * @export
 * @interface Document
 */
export interface Document {
  /**
   * The design hashed id
   * @type {string}
   * @memberof Document
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Document
   */
  user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Document
   */
  assigned_user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Document
   */
  project_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Document
   */
  vendor_id?: string;
  /**
   * The design name
   * @type {string}
   * @memberof Document
   */
  name?: string;
  /**
   * The design name
   * @type {string}
   * @memberof Document
   */
  url?: string;
  /**
   * The design name
   * @type {string}
   * @memberof Document
   */
  preview?: string;
  /**
   * The design name
   * @type {string}
   * @memberof Document
   */
  type?: string;
  /**
   * The design name
   * @type {string}
   * @memberof Document
   */
  disk?: string;
  /**
   * The design name
   * @type {string}
   * @memberof Document
   */
  hash?: string;
  /**
   * Flag to determine if the design is deleted
   * @type {boolean}
   * @memberof Document
   */
  is_deleted?: boolean;
  /**
   * Flag to determine if the document is a default doc
   * @type {boolean}
   * @memberof Document
   */
  is_default?: boolean;
  /**
   * Timestamp
   * @type {number}
   * @memberof Document
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Document
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Document
   */
  deleted_at?: number;
}
/**
 *
 * @export
 * @interface Expense
 */
export interface Expense {
  /**
   * _________
   * @type {string}
   * @memberof Expense
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Expense
   */
  user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Expense
   */
  assigned_user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  client_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  invoice_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  bank_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  invoice_currency_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  expense_currency_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  invoice_category_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  payment_type_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  recurring_expense_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  private_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  public_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  transaction_reference?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  transcation_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  tax_name1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  tax_name2?: string;
  /**
   * _________
   * @type {number}
   * @memberof Expense
   */
  tax_rate1?: number;
  /**
   * _________
   * @type {number}
   * @memberof Expense
   */
  tax_rate2?: number;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  tax_name3?: string;
  /**
   * _________
   * @type {number}
   * @memberof Expense
   */
  tax_rate3?: number;
  /**
   * _________
   * @type {number}
   * @memberof Expense
   */
  amount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Expense
   */
  foreign_amount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Expense
   */
  exchange_rate?: number;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  date?: string;
  /**
   * ________
   * @type {string}
   * @memberof Expense
   */
  payment_date?: string;
  /**
   * _________
   * @type {boolean}
   * @memberof Expense
   */
  should_be_invoiced?: boolean;
  /**
   * _________
   * @type {boolean}
   * @memberof Expense
   */
  is_deleted?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Expense
   */
  invoice_documents?: boolean;
  /**
   * Timestamp
   * @type {number}
   * @memberof Expense
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Expense
   */
  archived_at?: number;
}
/**
 *
 * @export
 * @interface ExpenseCategory
 */
export interface ExpenseCategory {
  /**
   * ______
   * @type {string}
   * @memberof ExpenseCategory
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof ExpenseCategory
   */
  name?: string;
  /**
   * ______
   * @type {string}
   * @memberof ExpenseCategory
   */
  user_id?: string;
  /**
   * ______
   * @type {boolean}
   * @memberof ExpenseCategory
   */
  is_deleted?: boolean;
  /**
   * ______
   * @type {string}
   * @memberof ExpenseCategory
   */
  updated_at?: string;
  /**
   * ______
   * @type {string}
   * @memberof ExpenseCategory
   */
  created_at?: string;
}
/**
 *
 * @export
 * @interface FeesAndLimits
 */
export interface FeesAndLimits {
  /**
   * ______
   * @type {string}
   * @memberof FeesAndLimits
   */
  min_limit?: string;
  /**
   * ______
   * @type {string}
   * @memberof FeesAndLimits
   */
  max_limit?: string;
  /**
   * ______
   * @type {number}
   * @memberof FeesAndLimits
   */
  fee_amount?: number;
  /**
   * ______
   * @type {number}
   * @memberof FeesAndLimits
   */
  fee_percent?: number;
  /**
   * ______
   * @type {string}
   * @memberof FeesAndLimits
   */
  fee_tax_name1?: string;
  /**
   * ______
   * @type {string}
   * @memberof FeesAndLimits
   */
  fee_tax_name2?: string;
  /**
   * ______
   * @type {string}
   * @memberof FeesAndLimits
   */
  fee_tax_name3?: string;
  /**
   * ______
   * @type {number}
   * @memberof FeesAndLimits
   */
  fee_tax_rate1?: number;
  /**
   * ______
   * @type {number}
   * @memberof FeesAndLimits
   */
  fee_tax_rate2?: number;
  /**
   * ______
   * @type {number}
   * @memberof FeesAndLimits
   */
  fee_tax_rate3?: number;
  /**
   * ______
   * @type {number}
   * @memberof FeesAndLimits
   */
  fee_cap?: number;
  /**
   * ______
   * @type {boolean}
   * @memberof FeesAndLimits
   */
  adjust_fee_percent?: boolean;
}
/**
 *
 * @export
 * @interface GroupSetting
 */
export interface GroupSetting {
  /**
   * _________
   * @type {string}
   * @memberof GroupSetting
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof GroupSetting
   */
  user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof GroupSetting
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof GroupSetting
   */
  name?: string;
  /**
   * ________
   * @type {object}
   * @memberof GroupSetting
   */
  settings?: object;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   * The user email address
   * @type {string}
   * @memberof InlineObject
   */
  email?: string;
  /**
   * The signup users first name
   * @type {string}
   * @memberof InlineObject
   */
  first_name?: string;
  /**
   * The signup users last name
   * @type {string}
   * @memberof InlineObject
   */
  last_name?: string;
  /**
   * The user accepted the terms of service
   * @type {boolean}
   * @memberof InlineObject
   */
  terms_of_service?: boolean;
  /**
   * The user accepted the privacy policy
   * @type {boolean}
   * @memberof InlineObject
   */
  privacy_policy?: boolean;
  /**
   * The user password must meet minimum criteria ~ >6 characters
   * @type {string}
   * @memberof InlineObject
   */
  password?: string;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   * The user email address
   * @type {string}
   * @memberof InlineObject1
   */
  email?: string;
  /**
   * The user password must meet minimum criteria ~ >6 characters
   * @type {string}
   * @memberof InlineObject1
   */
  password?: string;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   * The start date of the statement period - format Y-m-d
   * @type {string}
   * @memberof InlineObject2
   */
  start_date?: string;
  /**
   * The start date of the statement period - format Y-m-d
   * @type {string}
   * @memberof InlineObject2
   */
  end_date?: string;
  /**
   * The hashed ID of the client
   * @type {string}
   * @memberof InlineObject2
   */
  client_id?: string;
  /**
   * Flag which determines if the payments table is shown
   * @type {boolean}
   * @memberof InlineObject2
   */
  show_payments_table?: boolean;
  /**
   * Flag which determines if the aging table is shown
   * @type {boolean}
   * @memberof InlineObject2
   */
  show_aging_table?: boolean;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   * The email subject
   * @type {string}
   * @memberof InlineObject3
   */
  subject?: string;
  /**
   * The email body
   * @type {string}
   * @memberof InlineObject3
   */
  body?: string;
  /**
   * The entity name
   * @type {string}
   * @memberof InlineObject3
   */
  entity?: string;
  /**
   * The entity_id
   * @type {string}
   * @memberof InlineObject3
   */
  entity_id?: string;
  /**
   * The template required
   * @type {string}
   * @memberof InlineObject3
   */
  template?: string;
}
/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   * The email template subject
   * @type {string}
   * @memberof InlineObject4
   */
  subject?: string;
  /**
   * The email template body
   * @type {string}
   * @memberof InlineObject4
   */
  body?: string;
}
/**
 *
 * @export
 * @interface Invoice
 */
export interface Invoice {
  /**
   * _________
   * @type {string}
   * @memberof Invoice
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Invoice
   */
  user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Invoice
   */
  assigned_user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  client_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  status_id?: string;
  /**
   * The invoice number - is a unique alpha numeric number per invoice per company
   * @type {string}
   * @memberof Invoice
   */
  number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  po_number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  terms?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  public_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  private_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  footer?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  tax_name1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  tax_name2?: string;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  tax_rate1?: number;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  tax_rate2?: number;
  /**
   * ________
   * @type {string}
   * @memberof Invoice
   */
  tax_name3?: string;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  tax_rate3?: number;
  /**
   * The total taxes for the invoice
   * @type {number}
   * @memberof Invoice
   */
  total_taxes?: number;
  /**
   * _________
   * @type {object}
   * @memberof Invoice
   */
  line_items?: object;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  amount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  balance?: number;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  paid_to_date?: number;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  discount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Invoice
   */
  partial?: number;
  /**
   * _________
   * @type {boolean}
   * @memberof Invoice
   */
  is_amount_discount?: boolean;
  /**
   * _________
   * @type {boolean}
   * @memberof Invoice
   */
  is_deleted?: boolean;
  /**
   * Defines the type of taxes used as either inclusive or exclusive
   * @type {boolean}
   * @memberof Invoice
   */
  uses_inclusive_taxes?: boolean;
  /**
   * The Invoice Date
   * @type {string}
   * @memberof Invoice
   */
  date?: string;
  /**
   * The last date the invoice was sent out
   * @type {string}
   * @memberof Invoice
   */
  last_sent_date?: string;
  /**
   * The Next date for a reminder to be sent
   * @type {string}
   * @memberof Invoice
   */
  next_send_date?: string;
  /**
   * _________
   * @type {string}
   * @memberof Invoice
   */
  partial_due_date?: string;
  /**
   * _________
   * @type {string}
   * @memberof Invoice
   */
  due_date?: string;
  /**
   *
   * @type {CompanySettings}
   * @memberof Invoice
   */
  settings?: CompanySettings;
  /**
   * Timestamp
   * @type {number}
   * @memberof Invoice
   */
  last_viewed?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Invoice
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Invoice
   */
  archived_at?: number;
  /**
   * First Custom Surcharge
   * @type {number}
   * @memberof Invoice
   */
  custom_surcharge1?: number;
  /**
   * Second Custom Surcharge
   * @type {number}
   * @memberof Invoice
   */
  custom_surcharge2?: number;
  /**
   * Third Custom Surcharge
   * @type {number}
   * @memberof Invoice
   */
  custom_surcharge3?: number;
  /**
   * Fourth Custom Surcharge
   * @type {number}
   * @memberof Invoice
   */
  custom_surcharge4?: number;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Invoice
   */
  custom_surcharge_tax1?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Invoice
   */
  custom_surcharge_tax2?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Invoice
   */
  custom_surcharge_tax3?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Invoice
   */
  custom_surcharge_tax4?: boolean;
}
/**
 *
 * @export
 * @interface InvoicePaymentable
 */
export interface InvoicePaymentable {
  /**
   * ______
   * @type {string}
   * @memberof InvoicePaymentable
   */
  invoice_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof InvoicePaymentable
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * The company name
   * @type {string}
   * @memberof ModelError
   */
  message?: string;
  /**
   * The HTTP error code
   * @type {number}
   * @memberof ModelError
   */
  code?: number;
}
/**
 *
 * @export
 * @interface Payment
 */
export interface Payment {
  /**
   * ______
   * @type {string}
   * @memberof Payment
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Payment
   */
  client_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Payment
   */
  invitation_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Payment
   */
  client_contact_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Payment
   */
  user_id?: string;
  /**
   * The Payment Type ID
   * @type {string}
   * @memberof Payment
   */
  type_id?: string;
  /**
   * The Payment date
   * @type {string}
   * @memberof Payment
   */
  date?: string;
  /**
   * The transaction reference as defined by the payment gateway
   * @type {string}
   * @memberof Payment
   */
  transaction_reference?: string;
  /**
   * ______
   * @type {string}
   * @memberof Payment
   */
  assigned_user_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Payment
   */
  private_notes?: string;
  /**
   * ______
   * @type {boolean}
   * @memberof Payment
   */
  is_manual?: boolean;
  /**
   * ______
   * @type {boolean}
   * @memberof Payment
   */
  is_deleted?: boolean;
  /**
   * The amount of this payment
   * @type {number}
   * @memberof Payment
   */
  amount?: number;
  /**
   * The refunded amount of this payment
   * @type {number}
   * @memberof Payment
   */
  refunded?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Payment
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Payment
   */
  archived_at?: number;
  /**
   * The company gateway id
   * @type {string}
   * @memberof Payment
   */
  company_gateway_id?: string;
  /**
   *
   * @type {Paymentable}
   * @memberof Payment
   */
  paymentables?: Paymentable;
  /**
   *
   * @type {Array<InvoicePaymentable>}
   * @memberof Payment
   */
  invoices?: Array<InvoicePaymentable>;
  /**
   *
   * @type {Array<CreditPaymentable>}
   * @memberof Payment
   */
  credits?: Array<CreditPaymentable>;
}
/**
 *
 * @export
 * @interface PaymentTerm
 */
export interface PaymentTerm {
  /**
   * The payment term length in days
   * @type {number}
   * @memberof PaymentTerm
   */
  num_days?: number;
  /**
   * The payment term length in string format
   * @type {string}
   * @memberof PaymentTerm
   */
  name?: string;
  /**
   * Timestamp
   * @type {number}
   * @memberof PaymentTerm
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof PaymentTerm
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof PaymentTerm
   */
  archived_at?: number;
}
/**
 *
 * @export
 * @interface Paymentable
 */
export interface Paymentable {
  /**
   * The paymentable hashed id
   * @type {string}
   * @memberof Paymentable
   */
  id?: string;
  /**
   * The invoice hashed id
   * @type {string}
   * @memberof Paymentable
   */
  invoice_id?: string;
  /**
   * The credit hashed id
   * @type {string}
   * @memberof Paymentable
   */
  credit_id?: string;
  /**
   * ______
   * @type {number}
   * @memberof Paymentable
   */
  refunded?: number;
  /**
   * ______
   * @type {number}
   * @memberof Paymentable
   */
  amount?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Paymentable
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Paymentable
   */
  created_at?: number;
}
/**
 *
 * @export
 * @interface Product
 */
export interface Product {
  /**
   * ______
   * @type {string}
   * @memberof Product
   */
  id?: string;
}
/**
 *
 * @export
 * @interface Project
 */
export interface Project {
  /**
   * ______
   * @type {string}
   * @memberof Project
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Project
   */
  name?: string;
}
/**
 *
 * @export
 * @interface Quote
 */
export interface Quote {
  /**
   * _________
   * @type {string}
   * @memberof Quote
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Quote
   */
  user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Quote
   */
  assigned_user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  client_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  status_id?: string;
  /**
   * The quote number - is a unique alpha numeric number per quote per company
   * @type {string}
   * @memberof Quote
   */
  number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  po_number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  terms?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  public_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  private_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  footer?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  tax_name1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  tax_name2?: string;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  tax_rate1?: number;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  tax_rate2?: number;
  /**
   * ________
   * @type {string}
   * @memberof Quote
   */
  tax_name3?: string;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  tax_rate3?: number;
  /**
   * The total taxes for the quote
   * @type {number}
   * @memberof Quote
   */
  total_taxes?: number;
  /**
   * _________
   * @type {object}
   * @memberof Quote
   */
  line_items?: object;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  amount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  balance?: number;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  paid_to_date?: number;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  discount?: number;
  /**
   * _________
   * @type {number}
   * @memberof Quote
   */
  partial?: number;
  /**
   * _________
   * @type {boolean}
   * @memberof Quote
   */
  is_amount_discount?: boolean;
  /**
   * _________
   * @type {boolean}
   * @memberof Quote
   */
  is_deleted?: boolean;
  /**
   * Defines the type of taxes used as either inclusive or exclusive
   * @type {boolean}
   * @memberof Quote
   */
  uses_inclusive_taxes?: boolean;
  /**
   * The Quote Date
   * @type {string}
   * @memberof Quote
   */
  date?: string;
  /**
   * The last date the quote was sent out
   * @type {string}
   * @memberof Quote
   */
  last_sent_date?: string;
  /**
   * The Next date for a reminder to be sent
   * @type {string}
   * @memberof Quote
   */
  next_send_date?: string;
  /**
   * _________
   * @type {string}
   * @memberof Quote
   */
  partial_due_date?: string;
  /**
   * _________
   * @type {string}
   * @memberof Quote
   */
  due_date?: string;
  /**
   *
   * @type {CompanySettings}
   * @memberof Quote
   */
  settings?: CompanySettings;
  /**
   * Timestamp
   * @type {number}
   * @memberof Quote
   */
  last_viewed?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Quote
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Quote
   */
  archived_at?: number;
  /**
   * First Custom Surcharge
   * @type {number}
   * @memberof Quote
   */
  custom_surcharge1?: number;
  /**
   * Second Custom Surcharge
   * @type {number}
   * @memberof Quote
   */
  custom_surcharge2?: number;
  /**
   * Third Custom Surcharge
   * @type {number}
   * @memberof Quote
   */
  custom_surcharge3?: number;
  /**
   * Fourth Custom Surcharge
   * @type {number}
   * @memberof Quote
   */
  custom_surcharge4?: number;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Quote
   */
  custom_surcharge_tax1?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Quote
   */
  custom_surcharge_tax2?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Quote
   */
  custom_surcharge_tax3?: boolean;
  /**
   * Toggles charging taxes on custom surcharge amounts
   * @type {boolean}
   * @memberof Quote
   */
  custom_surcharge_tax4?: boolean;
}
/**
 *
 * @export
 * @interface RecurringInvoice
 */
export interface RecurringInvoice {
  /**
   * ______
   * @type {string}
   * @memberof RecurringInvoice
   */
  id?: string;
}
/**
 *
 * @export
 * @interface RecurringQuote
 */
export interface RecurringQuote {
  /**
   * ______
   * @type {string}
   * @memberof RecurringQuote
   */
  id?: string;
}
/**
 *
 * @export
 * @interface Subscription
 */
export interface Subscription {
  /**
   * ______
   * @type {string}
   * @memberof Subscription
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Subscription
   */
  user_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Subscription
   */
  product_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Subscription
   */
  company_id?: string;
  /**
   * ______
   * @type {string}
   * @memberof Subscription
   */
  recurring_invoice_id?: string;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  is_recurring?: boolean;
  /**
   * integer const representation of the frequency
   * @type {string}
   * @memberof Subscription
   */
  frequency_id?: string;
  /**
   * enum setting
   * @type {string}
   * @memberof Subscription
   */
  auto_bill?: string;
  /**
   * ______
   * @type {string}
   * @memberof Subscription
   */
  promo_code?: string;
  /**
   * ______
   * @type {number}
   * @memberof Subscription
   */
  promo_discount?: number;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  is_amount_discount?: boolean;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  allow_cancellation?: boolean;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  per_seat_enabled?: boolean;
  /**
   * ______
   * @type {number}
   * @memberof Subscription
   */
  currency_id?: number;
  /**
   * ______
   * @type {number}
   * @memberof Subscription
   */
  max_seats_limit?: number;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  trial_enabled?: boolean;
  /**
   * ______
   * @type {number}
   * @memberof Subscription
   */
  trial_duration?: number;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  allow_query_overrides?: boolean;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  allow_plan_changes?: boolean;
  /**
   * ______
   * @type {number}
   * @memberof Subscription
   */
  refund_period?: number;
  /**
   * ______
   * @type {string}
   * @memberof Subscription
   */
  webhook_configuration?: string;
  /**
   * ______
   * @type {boolean}
   * @memberof Subscription
   */
  is_deleted?: boolean;
  /**
   * Timestamp
   * @type {number}
   * @memberof Subscription
   */
  archived_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Subscription
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Subscription
   */
  updated_at?: number;
}
/**
 *
 * @export
 * @interface SystemLog
 */
export interface SystemLog {
  /**
   * The account hashed id
   * @type {string}
   * @memberof SystemLog
   */
  id?: string;
  /**
   * The company hashed id
   * @type {string}
   * @memberof SystemLog
   */
  company_id?: string;
  /**
   * The user_id hashed id
   * @type {string}
   * @memberof SystemLog
   */
  user_id?: string;
  /**
   * The client_id hashed id
   * @type {string}
   * @memberof SystemLog
   */
  client_id?: string;
  /**
   * The Log Type ID
   * @type {number}
   * @memberof SystemLog
   */
  event_id?: number;
  /**
   * The Category Type ID
   * @type {number}
   * @memberof SystemLog
   */
  category_id?: number;
  /**
   * The Type Type ID
   * @type {number}
   * @memberof SystemLog
   */
  type_id?: number;
  /**
   * The json object of the error
   * @type {object}
   * @memberof SystemLog
   */
  log?: object;
  /**
   * ______
   * @type {string}
   * @memberof SystemLog
   */
  updated_at?: string;
  /**
   * ______
   * @type {string}
   * @memberof SystemLog
   */
  created_at?: string;
}
/**
 *
 * @export
 * @interface Task
 */
export interface Task {
  /**
   * _________
   * @type {string}
   * @memberof Task
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Task
   */
  user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Task
   */
  assigned_user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  client_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  invoice_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  project_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  time_log?: string;
  /**
   * ________
   * @type {boolean}
   * @memberof Task
   */
  is_running?: boolean;
  /**
   * ________
   * @type {boolean}
   * @memberof Task
   */
  is_deleted?: boolean;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  task_status_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  description?: string;
  /**
   * ________
   * @type {number}
   * @memberof Task
   */
  duration?: number;
  /**
   * ________
   * @type {number}
   * @memberof Task
   */
  task_status_order?: number;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof Task
   */
  custom_value4?: string;
  /**
   * Timestamp
   * @type {number}
   * @memberof Task
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Task
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Task
   */
  archived_at?: number;
}
/**
 *
 * @export
 * @interface TaskStatus
 */
export interface TaskStatus {
  /**
   * The task status name
   * @type {string}
   * @memberof TaskStatus
   */
  name?: string;
  /**
   * Timestamp
   * @type {number}
   * @memberof TaskStatus
   */
  created_at?: number;
  /**
   * ______
   * @type {boolean}
   * @memberof TaskStatus
   */
  is_deleted?: boolean;
  /**
   * Timestamp
   * @type {number}
   * @memberof TaskStatus
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof TaskStatus
   */
  archived_at?: number;
}
/**
 *
 * @export
 * @interface TaxRate
 */
export interface TaxRate {
  /**
   * ______
   * @type {string}
   * @memberof TaxRate
   */
  id?: string;
  /**
   * ______
   * @type {string}
   * @memberof TaxRate
   */
  name?: string;
  /**
   * ______
   * @type {number}
   * @memberof TaxRate
   */
  rate?: number;
  /**
   * ______
   * @type {boolean}
   * @memberof TaxRate
   */
  is_deleted?: boolean;
}
/**
 *
 * @export
 * @interface Template
 */
export interface Template {
  /**
   * The template HTML
   * @type {string}
   * @memberof Template
   */
  html?: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   * __________
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   * ________
   * @type {string}
   * @memberof User
   */
  first_name?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  last_name?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  phone?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  signature?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  avatar?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  accepted_terms_version?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  oauth_user_id?: string;
  /**
   * _________
   * @type {string}
   * @memberof User
   */
  oauth_provider_id?: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   * The error message
   * @type {string}
   * @memberof ValidationError
   */
  message?: string;
  /**
   *
   * @type {ValidationErrorErrors}
   * @memberof ValidationError
   */
  errors?: ValidationErrorErrors;
}
/**
 *
 * @export
 * @interface ValidationErrorErrors
 */
export interface ValidationErrorErrors {
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationErrorErrors
   */
  value?: Array<string>;
}
/**
 *
 * @export
 * @interface Vendor
 */
export interface Vendor {
  /**
   * _________
   * @type {string}
   * @memberof Vendor
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Vendor
   */
  user_id?: string;
  /**
   * __________
   * @type {string}
   * @memberof Vendor
   */
  assigned_user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  client_id?: string;
  /**
   *
   * @type {Array<VendorContact>}
   * @memberof Vendor
   */
  contacts?: Array<VendorContact>;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  name?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  website?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  private_notes?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  industry_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  size_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  address1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  address2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  city?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  state?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  postal_code?: string;
  /**
   * The client phone number
   * @type {string}
   * @memberof Vendor
   */
  work_phone?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  country_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  currency_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  vat_number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  id_number?: string;
  /**
   * ________
   * @type {string}
   * @memberof Vendor
   */
  number?: string;
  /**
   * ________
   * @type {boolean}
   * @memberof Vendor
   */
  is_deleted?: boolean;
  /**
   * Timestamp
   * @type {number}
   * @memberof Vendor
   */
  last_login?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Vendor
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof Vendor
   */
  updated_at?: number;
  /**
   *
   * @type {CompanySettings}
   * @memberof Vendor
   */
  settings?: CompanySettings;
}
/**
 *
 * @export
 * @interface VendorContact
 */
export interface VendorContact {
  /**
   * _________
   * @type {string}
   * @memberof VendorContact
   */
  id?: string;
  /**
   * __________
   * @type {string}
   * @memberof VendorContact
   */
  user_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  company_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  vendor_id?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  first_name?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  last_name?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  phone?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  custom_value1?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  custom_value2?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  custom_value3?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  custom_value4?: string;
  /**
   * ________
   * @type {string}
   * @memberof VendorContact
   */
  email?: string;
  /**
   * ________
   * @type {boolean}
   * @memberof VendorContact
   */
  is_primary?: boolean;
  /**
   * Timestamp
   * @type {number}
   * @memberof VendorContact
   */
  created_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof VendorContact
   */
  updated_at?: number;
  /**
   * Timestamp
   * @type {number}
   * @memberof VendorContact
   */
  deleted_at?: number;
}
/**
 *
 * @export
 * @interface Webhook
 */
export interface Webhook {
  /**
   * The subscription hashed id
   * @type {string}
   * @memberof Webhook
   */
  id?: string;
  /**
   * The subscription event id
   * @type {string}
   * @memberof Webhook
   */
  event_id?: string;
  /**
   * The api endpoint
   * @type {string}
   * @memberof Webhook
   */
  target_url?: string;
  /**
   * JSON or UBL
   * @type {string}
   * @memberof Webhook
   */
  format?: string;
}

/**
 * ActvitiesApi - axios parameter creator
 * @export
 */
export const ActvitiesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists all activities
     * @summary Gets a list of actvities
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {number} [rows] The number of activities to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      rows?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getActivities", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getActivities", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getActivities", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/actvities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (rows !== undefined) {
        localVarQueryParameter["rows"] = rows;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a PDF for the given activity
     * @summary Gets a PDF for the given activity
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} activityId The Activity Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityHistoricalEntityPdf: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      activityId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists(
        "getActivityHistoricalEntityPdf",
        "xApiSecret",
        xApiSecret
      );
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists(
        "getActivityHistoricalEntityPdf",
        "xApiToken",
        xApiToken
      );
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getActivityHistoricalEntityPdf",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'activityId' is not null or undefined
      assertParamExists(
        "getActivityHistoricalEntityPdf",
        "activityId",
        activityId
      );
      const localVarPath =
        `/api/v1/actvities/download_entity/{activity_id}`.replace(
          `{${"activity_id"}}`,
          encodeURIComponent(String(activityId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ActvitiesApi - functional programming interface
 * @export
 */
export const ActvitiesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ActvitiesApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists all activities
     * @summary Gets a list of actvities
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {number} [rows] The number of activities to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivities(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      rows?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        rows,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Gets a PDF for the given activity
     * @summary Gets a PDF for the given activity
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} activityId The Activity Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivityHistoricalEntityPdf(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      activityId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getActivityHistoricalEntityPdf(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          activityId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ActvitiesApi - factory interface
 * @export
 */
export const ActvitiesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ActvitiesApiFp(configuration);
  return {
    /**
     * Lists all activities
     * @summary Gets a list of actvities
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {number} [rows] The number of activities to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivities(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      rows?: number,
      options?: any
    ): AxiosPromise<Activity> {
      return localVarFp
        .getActivities(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          rows,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a PDF for the given activity
     * @summary Gets a PDF for the given activity
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} activityId The Activity Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityHistoricalEntityPdf(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      activityId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getActivityHistoricalEntityPdf(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          activityId,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ActvitiesApi - object-oriented interface
 * @export
 * @class ActvitiesApi
 * @extends {BaseAPI}
 */
export class ActvitiesApi extends BaseAPI {
  /**
   * Lists all activities
   * @summary Gets a list of actvities
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {number} [rows] The number of activities to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActvitiesApi
   */
  public getActivities(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    rows?: number,
    options?: any
  ) {
    return ActvitiesApiFp(this.configuration)
      .getActivities(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        rows,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a PDF for the given activity
   * @summary Gets a PDF for the given activity
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} activityId The Activity Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActvitiesApi
   */
  public getActivityHistoricalEntityPdf(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    activityId: string,
    options?: any
  ) {
    return ActvitiesApiFp(this.configuration)
      .getActivityHistoricalEntityPdf(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        activityId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClaimLicenseApi - axios parameter creator
 * @export
 */
export const ClaimLicenseApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Attempts to claim a white label license
     * @summary Attempts to claim a white label license
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} licenseKey The license hash
     * @param {string} productId The ID of the product purchased.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClaimLicense: async (
      xApiSecret: string,
      xRequestedWith: string,
      licenseKey: string,
      productId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getClaimLicense", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getClaimLicense", "xRequestedWith", xRequestedWith);
      // verify required parameter 'licenseKey' is not null or undefined
      assertParamExists("getClaimLicense", "licenseKey", licenseKey);
      // verify required parameter 'productId' is not null or undefined
      assertParamExists("getClaimLicense", "productId", productId);
      const localVarPath = `/api/v1/claim_license`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (licenseKey !== undefined) {
        localVarQueryParameter["license_key"] = licenseKey;
      }

      if (productId !== undefined) {
        localVarQueryParameter["product_id"] = productId;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClaimLicenseApi - functional programming interface
 * @export
 */
export const ClaimLicenseApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ClaimLicenseApiAxiosParamCreator(configuration);
  return {
    /**
     * Attempts to claim a white label license
     * @summary Attempts to claim a white label license
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} licenseKey The license hash
     * @param {string} productId The ID of the product purchased.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClaimLicense(
      xApiSecret: string,
      xRequestedWith: string,
      licenseKey: string,
      productId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimLicense(
        xApiSecret,
        xRequestedWith,
        licenseKey,
        productId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ClaimLicenseApi - factory interface
 * @export
 */
export const ClaimLicenseApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClaimLicenseApiFp(configuration);
  return {
    /**
     * Attempts to claim a white label license
     * @summary Attempts to claim a white label license
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} licenseKey The license hash
     * @param {string} productId The ID of the product purchased.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClaimLicense(
      xApiSecret: string,
      xRequestedWith: string,
      licenseKey: string,
      productId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getClaimLicense(
          xApiSecret,
          xRequestedWith,
          licenseKey,
          productId,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClaimLicenseApi - object-oriented interface
 * @export
 * @class ClaimLicenseApi
 * @extends {BaseAPI}
 */
export class ClaimLicenseApi extends BaseAPI {
  /**
   * Attempts to claim a white label license
   * @summary Attempts to claim a white label license
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} licenseKey The license hash
   * @param {string} productId The ID of the product purchased.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClaimLicenseApi
   */
  public getClaimLicense(
    xApiSecret: string,
    xRequestedWith: string,
    licenseKey: string,
    productId: string,
    options?: any
  ) {
    return ClaimLicenseApiFp(this.configuration)
      .getClaimLicense(
        xApiSecret,
        xRequestedWith,
        licenseKey,
        productId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClientGatewayTokensApi - axios parameter creator
 * @export
 */
export const ClientGatewayTokensApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClientGatewayToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteClientGatewayToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteClientGatewayToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "deleteClientGatewayToken",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteClientGatewayToken", "id", id);
      const localVarPath = `/api/v1/client_gateway_tokens/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editClientGatewayToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editClientGatewayToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editClientGatewayToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "editClientGatewayToken",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editClientGatewayToken", "id", id);
      const localVarPath = `/api/v1/client_gateway_tokens/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists client_gateway_tokens, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the client_gateway_tokens, these are handled by the ClientGatewayTokenFilters class which defines the methods available
     * @summary Gets a list of client_gateway_tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientGatewayTokens: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getClientGatewayTokens", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getClientGatewayTokens", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getClientGatewayTokens",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/client_gateway_tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientGatewayTokensCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists(
        "getClientGatewayTokensCreate",
        "xApiSecret",
        xApiSecret
      );
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getClientGatewayTokensCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getClientGatewayTokensCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/client_gateway_tokens/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showClientGatewayToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showClientGatewayToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showClientGatewayToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "showClientGatewayToken",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showClientGatewayToken", "id", id);
      const localVarPath = `/api/v1/client_gateway_tokens/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeClientGatewayToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeClientGatewayToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeClientGatewayToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "storeClientGatewayToken",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/client_gateway_tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClientGatewayToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateClientGatewayToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateClientGatewayToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "updateClientGatewayToken",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateClientGatewayToken", "id", id);
      const localVarPath = `/api/v1/client_gateway_tokens/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClientGatewayTokensApi - functional programming interface
 * @export
 */
export const ClientGatewayTokensApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    ClientGatewayTokensApiAxiosParamCreator(configuration);
  return {
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientGatewayToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists client_gateway_tokens, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the client_gateway_tokens, these are handled by the ClientGatewayTokenFilters class which defines the methods available
     * @summary Gets a list of client_gateway_tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClientGatewayTokens(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientGatewayToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getClientGatewayTokens(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClientGatewayTokensCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientGatewayToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getClientGatewayTokensCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientGatewayToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientGatewayToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.storeClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ClientGatewayToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ClientGatewayTokensApi - factory interface
 * @export
 */
export const ClientGatewayTokensApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClientGatewayTokensApiFp(configuration);
  return {
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<ClientGatewayToken> {
      return localVarFp
        .editClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists client_gateway_tokens, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the client_gateway_tokens, these are handled by the ClientGatewayTokenFilters class which defines the methods available
     * @summary Gets a list of client_gateway_tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientGatewayTokens(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<ClientGatewayToken> {
      return localVarFp
        .getClientGatewayTokens(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientGatewayTokensCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<ClientGatewayToken> {
      return localVarFp
        .getClientGatewayTokensCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<ClientGatewayToken> {
      return localVarFp
        .showClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<ClientGatewayToken> {
      return localVarFp
        .storeClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ClientGatewayToken Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClientGatewayToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<ClientGatewayToken> {
      return localVarFp
        .updateClientGatewayToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClientGatewayTokensApi - object-oriented interface
 * @export
 * @class ClientGatewayTokensApi
 * @extends {BaseAPI}
 */
export class ClientGatewayTokensApi extends BaseAPI {
  /**
   * Handles the deletion of a client by id
   * @summary Deletes a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ClientGatewayToken Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientGatewayTokensApi
   */
  public deleteClientGatewayToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientGatewayTokensApiFp(this.configuration)
      .deleteClientGatewayToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ClientGatewayToken Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientGatewayTokensApi
   */
  public editClientGatewayToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientGatewayTokensApiFp(this.configuration)
      .editClientGatewayToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists client_gateway_tokens, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the client_gateway_tokens, these are handled by the ClientGatewayTokenFilters class which defines the methods available
   * @summary Gets a list of client_gateway_tokens
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientGatewayTokensApi
   */
  public getClientGatewayTokens(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return ClientGatewayTokensApiFp(this.configuration)
      .getClientGatewayTokens(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank client object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientGatewayTokensApi
   */
  public getClientGatewayTokensCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ClientGatewayTokensApiFp(this.configuration)
      .getClientGatewayTokensCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ClientGatewayToken Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientGatewayTokensApi
   */
  public showClientGatewayToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientGatewayTokensApiFp(this.configuration)
      .showClientGatewayToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an client to a company
   * @summary Adds a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientGatewayTokensApi
   */
  public storeClientGatewayToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ClientGatewayTokensApiFp(this.configuration)
      .storeClientGatewayToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a client by id
   * @summary Updates a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ClientGatewayToken Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientGatewayTokensApi
   */
  public updateClientGatewayToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientGatewayTokensApiFp(this.configuration)
      .updateClientGatewayToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of clients
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkClients: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkClients", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkClients", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkClients", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkClients", "requestBody", requestBody);
      const localVarPath = `/api/v1/clients/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return a PDF of the client statement
     * @summary Return a PDF of the client statement
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject2} inlineObject2
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientStatement: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      inlineObject2: InlineObject2,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("clientStatement", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("clientStatement", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("clientStatement", "xRequestedWith", xRequestedWith);
      // verify required parameter 'inlineObject2' is not null or undefined
      assertParamExists("clientStatement", "inlineObject2", inlineObject2);
      const localVarPath = `/api/v1/client_statement`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject2,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClient: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteClient", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteClient", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteClient", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteClient", "id", id);
      const localVarPath = `/api/v1/clients/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editClient: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editClient", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editClient", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editClient", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editClient", "id", id);
      const localVarPath = `/api/v1/clients/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists clients, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the clients, these are handled by the ClientFilters class which defines the methods available
     * @summary Gets a list of clients
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClients: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getClients", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getClients", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getClients", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/clients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getClientsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getClientsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getClientsCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/clients/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showClient: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showClient", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showClient", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showClient", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showClient", "id", id);
      const localVarPath = `/api/v1/clients/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeClient: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeClient", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeClient", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeClient", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/clients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClient: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateClient", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateClient", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateClient", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateClient", "id", id);
      const localVarPath = `/api/v1/clients/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a client
     * @summary Uploads a document to a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadClient: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadClient", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadClient", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadClient", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadClient", "id", id);
      const localVarPath = `/api/v1/clients/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of clients
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkClients(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkClients(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return a PDF of the client statement
     * @summary Return a PDF of the client statement
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject2} inlineObject2
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clientStatement(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      inlineObject2: InlineObject2,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.clientStatement(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        inlineObject2,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClient(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editClient(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists clients, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the clients, these are handled by the ClientFilters class which defines the methods available
     * @summary Gets a list of clients
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClients(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClients(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClientsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getClientsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showClient(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeClient(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateClient(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a client
     * @summary Uploads a document to a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadClient(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ClientsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of clients
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkClients(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .bulkClients(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Return a PDF of the client statement
     * @summary Return a PDF of the client statement
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject2} inlineObject2
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clientStatement(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      inlineObject2: InlineObject2,
      include?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .clientStatement(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          inlineObject2,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteClient(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .editClient(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists clients, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the clients, these are handled by the ClientFilters class which defines the methods available
     * @summary Gets a list of clients
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClients(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .getClients(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .getClientsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .showClient(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .storeClient(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .updateClient(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a client
     * @summary Uploads a document to a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Client Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadClient(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Client> {
      return localVarFp
        .uploadClient(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of clients
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public bulkClients(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .bulkClients(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return a PDF of the client statement
   * @summary Return a PDF of the client statement
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {InlineObject2} inlineObject2
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public clientStatement(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    inlineObject2: InlineObject2,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .clientStatement(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        inlineObject2,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a client by id
   * @summary Deletes a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Client Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public deleteClient(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .deleteClient(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Client Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public editClient(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .editClient(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists clients, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the clients, these are handled by the ClientFilters class which defines the methods available
   * @summary Gets a list of clients
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public getClients(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .getClients(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank client object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public getClientsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .getClientsCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Client Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public showClient(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .showClient(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an client to a company
   * @summary Adds a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public storeClient(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .storeClient(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a client by id
   * @summary Updates a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Client Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public updateClient(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .updateClient(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a client
   * @summary Uploads a document to a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Client Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientsApi
   */
  public uploadClient(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ClientsApiFp(this.configuration)
      .uploadClient(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CompaniesApi - axios parameter creator
 * @export
 */
export const CompaniesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Handles the deletion of an company by id
     * @summary Deletes a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCompany: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteCompany", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteCompany", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteCompany", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteCompany", "id", id);
      const localVarPath = `/api/v1/companies/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an company by id
     * @summary Shows an company for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCompany: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editCompany", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editCompany", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editCompany", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editCompany", "id", id);
      const localVarPath = `/api/v1/companies/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists companies, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the companies, these are handled by the CompanyFilters class which defines the methods available
     * @summary Gets a list of companies
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanies: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getCompanies", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getCompanies", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getCompanies", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/companies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank company object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompaniesCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getCompaniesCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getCompaniesCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getCompaniesCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/companies/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an company by id
     * @summary Shows an company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showCompany: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showCompany", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showCompany", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showCompany", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showCompany", "id", id);
      const localVarPath = `/api/v1/companies/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an company to the system
     * @summary Adds a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCompany: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeCompany", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeCompany", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeCompany", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/companies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an company by id
     * @summary Updates an company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompany: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateCompany", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateCompany", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateCompany", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateCompany", "id", id);
      const localVarPath = `/api/v1/companies/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a company
     * @summary Uploads a document to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadCompanies: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadCompanies", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadCompanies", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadCompanies", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadCompanies", "id", id);
      const localVarPath = `/api/v1/companies/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CompaniesApi - functional programming interface
 * @export
 */
export const CompaniesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CompaniesApiAxiosParamCreator(configuration);
  return {
    /**
     * Handles the deletion of an company by id
     * @summary Deletes a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompany(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an company by id
     * @summary Shows an company for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editCompany(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists companies, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the companies, these are handled by the CompanyFilters class which defines the methods available
     * @summary Gets a list of companies
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompanies(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanies(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank company object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompaniesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCompaniesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an company by id
     * @summary Shows an company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showCompany(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an company to the system
     * @summary Adds a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeCompany(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an company by id
     * @summary Updates an company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompany(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a company
     * @summary Uploads a document to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadCompanies(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Company>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCompanies(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CompaniesApi - factory interface
 * @export
 */
export const CompaniesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CompaniesApiFp(configuration);
  return {
    /**
     * Handles the deletion of an company by id
     * @summary Deletes a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCompany(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an company by id
     * @summary Shows an company for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Company> {
      return localVarFp
        .editCompany(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists companies, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the companies, these are handled by the CompanyFilters class which defines the methods available
     * @summary Gets a list of companies
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanies(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Company> {
      return localVarFp
        .getCompanies(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank company object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompaniesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Company> {
      return localVarFp
        .getCompaniesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an company by id
     * @summary Shows an company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Company> {
      return localVarFp
        .showCompany(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an company to the system
     * @summary Adds a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Company> {
      return localVarFp
        .storeCompany(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an company by id
     * @summary Updates an company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Company> {
      return localVarFp
        .updateCompany(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a company
     * @summary Uploads a document to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Company Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadCompanies(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Company> {
      return localVarFp
        .uploadCompanies(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CompaniesApi - object-oriented interface
 * @export
 * @class CompaniesApi
 * @extends {BaseAPI}
 */
export class CompaniesApi extends BaseAPI {
  /**
   * Handles the deletion of an company by id
   * @summary Deletes a company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Company Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public deleteCompany(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .deleteCompany(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an company by id
   * @summary Shows an company for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Company Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public editCompany(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .editCompany(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists companies, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the companies, these are handled by the CompanyFilters class which defines the methods available
   * @summary Gets a list of companies
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public getCompanies(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .getCompanies(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank company object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public getCompaniesCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .getCompaniesCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an company by id
   * @summary Shows an company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Company Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public showCompany(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .showCompany(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an company to the system
   * @summary Adds a company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public storeCompany(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .storeCompany(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an company by id
   * @summary Updates an company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Company Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public updateCompany(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .updateCompany(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a company
   * @summary Uploads a document to a company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Company Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompaniesApi
   */
  public uploadCompanies(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompaniesApiFp(this.configuration)
      .uploadCompanies(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CompanyGatewaysApi - axios parameter creator
 * @export
 */
export const CompanyGatewaysApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of company_gateways
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Array of company gateway IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCompanyGateways: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkCompanyGateways", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkCompanyGateways", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "bulkCompanyGateways",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkCompanyGateways", "requestBody", requestBody);
      const localVarPath = `/api/v1/company_gateways/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an CompanyGateway by id
     * @summary Deletes a CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCompanyGateway: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteCompanyGateway", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteCompanyGateway", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "deleteCompanyGateway",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteCompanyGateway", "id", id);
      const localVarPath = `/api/v1/company_gateways/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an CompanyGateway by id
     * @summary Shows an CompanyGateway for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCompanyGateway: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editCompanyGateway", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editCompanyGateway", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editCompanyGateway", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editCompanyGateway", "id", id);
      const localVarPath = `/api/v1/company_gateways/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists company_gateways, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the company_gateways, these are handled by the CompanyGatewayFilters class which defines the methods available
     * @summary Gets a list of company_gateways
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyGateways: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getCompanyGateways", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getCompanyGateways", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getCompanyGateways", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/company_gateways`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank CompanyGateway object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyGatewaysCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getCompanyGatewaysCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getCompanyGatewaysCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getCompanyGatewaysCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/company_gateways/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an CompanyGateway by id
     * @summary Shows an CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showCompanyGateway: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showCompanyGateway", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showCompanyGateway", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showCompanyGateway", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showCompanyGateway", "id", id);
      const localVarPath = `/api/v1/company_gateways/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an CompanyGateway to the system
     * @summary Adds a CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCompanyGateway: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeCompanyGateway", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeCompanyGateway", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "storeCompanyGateway",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/company_gateways`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an CompanyGateway by id
     * @summary Updates an CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyGateway: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateCompanyGateway", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateCompanyGateway", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "updateCompanyGateway",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateCompanyGateway", "id", id);
      const localVarPath = `/api/v1/company_gateways/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CompanyGatewaysApi - functional programming interface
 * @export
 */
export const CompanyGatewaysApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CompanyGatewaysApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of company_gateways
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Array of company gateway IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCompanyGateways(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyGateway>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkCompanyGateways(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an CompanyGateway by id
     * @summary Deletes a CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an CompanyGateway by id
     * @summary Shows an CompanyGateway for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyGateway>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists company_gateways, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the company_gateways, these are handled by the CompanyGatewayFilters class which defines the methods available
     * @summary Gets a list of company_gateways
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompanyGateways(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyGateway>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCompanyGateways(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank CompanyGateway object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompanyGatewaysCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyGateway>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCompanyGatewaysCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an CompanyGateway by id
     * @summary Shows an CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyGateway>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an CompanyGateway to the system
     * @summary Adds a CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyGateway>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.storeCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an CompanyGateway by id
     * @summary Updates an CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyGateway>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CompanyGatewaysApi - factory interface
 * @export
 */
export const CompanyGatewaysApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CompanyGatewaysApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of company_gateways
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Array of company gateway IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCompanyGateways(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<CompanyGateway> {
      return localVarFp
        .bulkCompanyGateways(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an CompanyGateway by id
     * @summary Deletes a CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an CompanyGateway by id
     * @summary Shows an CompanyGateway for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyGateway> {
      return localVarFp
        .editCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists company_gateways, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the company_gateways, these are handled by the CompanyGatewayFilters class which defines the methods available
     * @summary Gets a list of company_gateways
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyGateways(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyGateway> {
      return localVarFp
        .getCompanyGateways(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank CompanyGateway object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyGatewaysCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyGateway> {
      return localVarFp
        .getCompanyGatewaysCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an CompanyGateway by id
     * @summary Shows an CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyGateway> {
      return localVarFp
        .showCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an CompanyGateway to the system
     * @summary Adds a CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyGateway> {
      return localVarFp
        .storeCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an CompanyGateway by id
     * @summary Updates an CompanyGateway
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The CompanyGateway Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyGateway(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyGateway> {
      return localVarFp
        .updateCompanyGateway(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CompanyGatewaysApi - object-oriented interface
 * @export
 * @class CompanyGatewaysApi
 * @extends {BaseAPI}
 */
export class CompanyGatewaysApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of company_gateways
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Array of company gateway IDs
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public bulkCompanyGateways(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .bulkCompanyGateways(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an CompanyGateway by id
   * @summary Deletes a CompanyGateway
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The CompanyGateway Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public deleteCompanyGateway(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .deleteCompanyGateway(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an CompanyGateway by id
   * @summary Shows an CompanyGateway for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The CompanyGateway Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public editCompanyGateway(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .editCompanyGateway(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists company_gateways, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the company_gateways, these are handled by the CompanyGatewayFilters class which defines the methods available
   * @summary Gets a list of company_gateways
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public getCompanyGateways(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .getCompanyGateways(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank CompanyGateway object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public getCompanyGatewaysCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .getCompanyGatewaysCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an CompanyGateway by id
   * @summary Shows an CompanyGateway
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The CompanyGateway Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public showCompanyGateway(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .showCompanyGateway(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an CompanyGateway to the system
   * @summary Adds a CompanyGateway
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public storeCompanyGateway(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .storeCompanyGateway(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an CompanyGateway by id
   * @summary Updates an CompanyGateway
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The CompanyGateway Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyGatewaysApi
   */
  public updateCompanyGateway(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CompanyGatewaysApiFp(this.configuration)
      .updateCompanyGateway(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CompanyLedgerApi - axios parameter creator
 * @export
 */
export const CompanyLedgerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists the company_ledger.
     * @summary Gets a list of company_ledger
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyLedger: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getCompanyLedger", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getCompanyLedger", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getCompanyLedger", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/company_ledger`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CompanyLedgerApi - functional programming interface
 * @export
 */
export const CompanyLedgerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CompanyLedgerApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists the company_ledger.
     * @summary Gets a list of company_ledger
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompanyLedger(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyLedger>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCompanyLedger(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CompanyLedgerApi - factory interface
 * @export
 */
export const CompanyLedgerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CompanyLedgerApiFp(configuration);
  return {
    /**
     * Lists the company_ledger.
     * @summary Gets a list of company_ledger
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompanyLedger(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyLedger> {
      return localVarFp
        .getCompanyLedger(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CompanyLedgerApi - object-oriented interface
 * @export
 * @class CompanyLedgerApi
 * @extends {BaseAPI}
 */
export class CompanyLedgerApi extends BaseAPI {
  /**
   * Lists the company_ledger.
   * @summary Gets a list of company_ledger
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyLedgerApi
   */
  public getCompanyLedger(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CompanyLedgerApiFp(this.configuration)
      .getCompanyLedger(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CompanyUserApi - axios parameter creator
 * @export
 */
export const CompanyUserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Attempts to update a company user record. A company user can modify only their settings fields. Full access for Admin users
     * @summary Update a company user record
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyUser: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateCompanyUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateCompanyUser", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/company_users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CompanyUserApi - functional programming interface
 * @export
 */
export const CompanyUserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CompanyUserApiAxiosParamCreator(configuration);
  return {
    /**
     * Attempts to update a company user record. A company user can modify only their settings fields. Full access for Admin users
     * @summary Update a company user record
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCompanyUser(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateCompanyUser(
          xApiSecret,
          xRequestedWith,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CompanyUserApi - factory interface
 * @export
 */
export const CompanyUserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CompanyUserApiFp(configuration);
  return {
    /**
     * Attempts to update a company user record. A company user can modify only their settings fields. Full access for Admin users
     * @summary Update a company user record
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCompanyUser(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<CompanyUser> {
      return localVarFp
        .updateCompanyUser(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CompanyUserApi - object-oriented interface
 * @export
 * @class CompanyUserApi
 * @extends {BaseAPI}
 */
export class CompanyUserApi extends BaseAPI {
  /**
   * Attempts to update a company user record. A company user can modify only their settings fields. Full access for Admin users
   * @summary Update a company user record
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CompanyUserApi
   */
  public updateCompanyUser(
    xApiSecret: string,
    xRequestedWith: string,
    options?: any
  ) {
    return CompanyUserApiFp(this.configuration)
      .updateCompanyUser(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ConnectedAccountApi - axios parameter creator
 * @export
 */
export const ConnectedAccountApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Refreshes the dataset
     * @summary Connect an oauth user to an existing user
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectedAccount: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("connectedAccount", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("connectedAccount", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("connectedAccount", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/connected_account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (includeStatic !== undefined) {
        localVarQueryParameter["include_static"] = includeStatic;
      }

      if (clearCache !== undefined) {
        localVarQueryParameter["clear_cache"] = clearCache;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConnectedAccountApi - functional programming interface
 * @export
 */
export const ConnectedAccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConnectedAccountApiAxiosParamCreator(configuration);
  return {
    /**
     * Refreshes the dataset
     * @summary Connect an oauth user to an existing user
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async connectedAccount(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.connectedAccount(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          includeStatic,
          clearCache,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ConnectedAccountApi - factory interface
 * @export
 */
export const ConnectedAccountApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ConnectedAccountApiFp(configuration);
  return {
    /**
     * Refreshes the dataset
     * @summary Connect an oauth user to an existing user
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectedAccount(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .connectedAccount(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          includeStatic,
          clearCache,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ConnectedAccountApi - object-oriented interface
 * @export
 * @class ConnectedAccountApi
 * @extends {BaseAPI}
 */
export class ConnectedAccountApi extends BaseAPI {
  /**
   * Refreshes the dataset
   * @summary Connect an oauth user to an existing user
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [includeStatic] Returns static variables
   * @param {string} [clearCache] Clears the static cache
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectedAccountApi
   */
  public connectedAccount(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    includeStatic?: string,
    clearCache?: string,
    options?: any
  ) {
    return ConnectedAccountApiFp(this.configuration)
      .connectedAccount(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        includeStatic,
        clearCache,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CreditsApi - axios parameter creator
 * @export
 */
export const CreditsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of credits
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCredits: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkCredits", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkCredits", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkCredits", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkCredits", "requestBody", requestBody);
      const localVarPath = `/api/v1/credits/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an credit by id
     * @summary Deletes a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredit: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteCredit", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteCredit", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteCredit", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteCredit", "id", id);
      const localVarPath = `/api/v1/credits/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an credit by id
     * @summary Shows an credit for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCredit: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editCredit", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editCredit", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editCredit", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editCredit", "id", id);
      const localVarPath = `/api/v1/credits/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists credits, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the credits, these are handled by the CreditFilters class which defines the methods available
     * @summary Gets a list of credits
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredits: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getCredits", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getCredits", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getCredits", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/credits`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank credit object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCreditsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getCreditsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getCreditsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getCreditsCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/credits/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an credit by id
     * @summary Shows an credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showCredit: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showCredit", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showCredit", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showCredit", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showCredit", "id", id);
      const localVarPath = `/api/v1/credits/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an credit to the system
     * @summary Adds a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCredit: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeCredit", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeCredit", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeCredit", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/credits`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an Credit by id
     * @summary Updates an Credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredit: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateCredit", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateCredit", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateCredit", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateCredit", "id", id);
      const localVarPath = `/api/v1/credits/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a credit
     * @summary Uploads a document to a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadCredits: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadCredits", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadCredits", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadCredits", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadCredits", "id", id);
      const localVarPath = `/api/v1/credits/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CreditsApi - functional programming interface
 * @export
 */
export const CreditsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CreditsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of credits
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCredits(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCredits(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an credit by id
     * @summary Deletes a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredit(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an credit by id
     * @summary Shows an credit for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editCredit(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists credits, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the credits, these are handled by the CreditFilters class which defines the methods available
     * @summary Gets a list of credits
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCredits(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCredits(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank credit object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCreditsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCreditsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an credit by id
     * @summary Shows an credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showCredit(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an credit to the system
     * @summary Adds a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeCredit(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an Credit by id
     * @summary Updates an Credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCredit(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a credit
     * @summary Uploads a document to a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadCredits(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCredits(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CreditsApi - factory interface
 * @export
 */
export const CreditsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CreditsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of credits
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCredits(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .bulkCredits(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an credit by id
     * @summary Deletes a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCredit(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an credit by id
     * @summary Shows an credit for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .editCredit(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists credits, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the credits, these are handled by the CreditFilters class which defines the methods available
     * @summary Gets a list of credits
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredits(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Credit> {
      return localVarFp
        .getCredits(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank credit object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCreditsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Credit> {
      return localVarFp
        .getCreditsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an credit by id
     * @summary Shows an credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Credit> {
      return localVarFp
        .showCredit(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an credit to the system
     * @summary Adds a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Credit> {
      return localVarFp
        .storeCredit(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an Credit by id
     * @summary Updates an Credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredit(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Credit> {
      return localVarFp
        .updateCredit(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a credit
     * @summary Uploads a document to a credit
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Credit Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadCredits(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Credit> {
      return localVarFp
        .uploadCredits(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CreditsApi - object-oriented interface
 * @export
 * @class CreditsApi
 * @extends {BaseAPI}
 */
export class CreditsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of credits
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public bulkCredits(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .bulkCredits(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an credit by id
   * @summary Deletes a credit
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Credit Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public deleteCredit(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .deleteCredit(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an credit by id
   * @summary Shows an credit for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public editCredit(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .editCredit(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists credits, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the credits, these are handled by the CreditFilters class which defines the methods available
   * @summary Gets a list of credits
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public getCredits(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .getCredits(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank credit object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public getCreditsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .getCreditsCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an credit by id
   * @summary Shows an credit
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Credit Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public showCredit(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .showCredit(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an credit to the system
   * @summary Adds a credit
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public storeCredit(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .storeCredit(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an Credit by id
   * @summary Updates an Credit
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Credit Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public updateCredit(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .updateCredit(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a credit
   * @summary Uploads a document to a credit
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Credit Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CreditsApi
   */
  public uploadCredits(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return CreditsApiFp(this.configuration)
      .uploadCredits(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DesignsApi - axios parameter creator
 * @export
 */
export const DesignsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of designs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDesigns: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkDesigns", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkDesigns", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkDesigns", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkDesigns", "requestBody", requestBody);
      const localVarPath = `/api/v1/designs/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a design by id
     * @summary Deletes a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDesign: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteDesign", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteDesign", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteDesign", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteDesign", "id", id);
      const localVarPath = `/api/v1/designs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a design by id
     * @summary Shows a design for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editDesign: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editDesign", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editDesign", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editDesign", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editDesign", "id", id);
      const localVarPath = `/api/v1/designs/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists designs
     * @summary Gets a list of designs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDesigns: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getDesigns", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getDesigns", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getDesigns", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/designs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank design object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDesignsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getDesignsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getDesignsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getDesignsCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/designs/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a design by id
     * @summary Shows a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showDesign: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showDesign", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showDesign", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showDesign", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showDesign", "id", id);
      const localVarPath = `/api/v1/designs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an design to a company
     * @summary Adds a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeDesign: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeDesign", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeDesign", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeDesign", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/designs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a design by id
     * @summary Updates a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDesign: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateDesign", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateDesign", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateDesign", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateDesign", "id", id);
      const localVarPath = `/api/v1/designs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DesignsApi - functional programming interface
 * @export
 */
export const DesignsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DesignsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of designs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDesigns(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Design>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDesigns(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a design by id
     * @summary Deletes a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDesign(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a design by id
     * @summary Shows a design for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Design>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editDesign(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists designs
     * @summary Gets a list of designs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDesigns(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Design>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDesigns(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank design object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDesignsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Design>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDesignsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a design by id
     * @summary Shows a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Design>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showDesign(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an design to a company
     * @summary Adds a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Design>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeDesign(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a design by id
     * @summary Updates a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Design>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDesign(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DesignsApi - factory interface
 * @export
 */
export const DesignsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DesignsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of designs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDesigns(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Design> {
      return localVarFp
        .bulkDesigns(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a design by id
     * @summary Deletes a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteDesign(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a design by id
     * @summary Shows a design for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Design> {
      return localVarFp
        .editDesign(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists designs
     * @summary Gets a list of designs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDesigns(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Design> {
      return localVarFp
        .getDesigns(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank design object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDesignsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Design> {
      return localVarFp
        .getDesignsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a design by id
     * @summary Shows a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Design> {
      return localVarFp
        .showDesign(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an design to a company
     * @summary Adds a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Design> {
      return localVarFp
        .storeDesign(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a design by id
     * @summary Updates a design
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Design Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDesign(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Design> {
      return localVarFp
        .updateDesign(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DesignsApi - object-oriented interface
 * @export
 * @class DesignsApi
 * @extends {BaseAPI}
 */
export class DesignsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of designs
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public bulkDesigns(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .bulkDesigns(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a design by id
   * @summary Deletes a design
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Design Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public deleteDesign(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .deleteDesign(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a design by id
   * @summary Shows a design for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Design Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public editDesign(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .editDesign(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists designs
   * @summary Gets a list of designs
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public getDesigns(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .getDesigns(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank design object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public getDesignsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .getDesignsCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a design by id
   * @summary Shows a design
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Design Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public showDesign(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .showDesign(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an design to a company
   * @summary Adds a design
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public storeDesign(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .storeDesign(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a design by id
   * @summary Updates a design
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Design Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DesignsApi
   */
  public updateDesign(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return DesignsApiFp(this.configuration)
      .updateDesign(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists documents, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the documents, these are handled by the DocumentsFilters class which defines the methods available
     * @summary Gets a list of documents
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocuments: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getDocuments", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getDocuments", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getDocuments", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/documents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DocumentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists documents, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the documents, these are handled by the DocumentsFilters class which defines the methods available
     * @summary Gets a list of documents
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDocuments(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDocuments(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DocumentsApiFp(configuration);
  return {
    /**
     * Lists documents, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the documents, these are handled by the DocumentsFilters class which defines the methods available
     * @summary Gets a list of documents
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDocuments(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Document> {
      return localVarFp
        .getDocuments(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
  /**
   * Lists documents, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the documents, these are handled by the DocumentsFilters class which defines the methods available
   * @summary Gets a list of documents
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DocumentsApi
   */
  public getDocuments(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return DocumentsApiFp(this.configuration)
      .getDocuments(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EmailsApi - axios parameter creator
 * @export
 */
export const EmailsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Sends an email for an entity
     * @summary Sends an email for an entity
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailTemplate: async (
      xApiSecret: string,
      xRequestedWith: string,
      inlineObject3: InlineObject3,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("sendEmailTemplate", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("sendEmailTemplate", "xRequestedWith", xRequestedWith);
      // verify required parameter 'inlineObject3' is not null or undefined
      assertParamExists("sendEmailTemplate", "inlineObject3", inlineObject3);
      const localVarPath = `/api/v1/emails`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject3,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EmailsApi - functional programming interface
 * @export
 */
export const EmailsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EmailsApiAxiosParamCreator(configuration);
  return {
    /**
     * Sends an email for an entity
     * @summary Sends an email for an entity
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendEmailTemplate(
      xApiSecret: string,
      xRequestedWith: string,
      inlineObject3: InlineObject3,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendEmailTemplate(
          xApiSecret,
          xRequestedWith,
          inlineObject3,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * EmailsApi - factory interface
 * @export
 */
export const EmailsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EmailsApiFp(configuration);
  return {
    /**
     * Sends an email for an entity
     * @summary Sends an email for an entity
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject3} inlineObject3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendEmailTemplate(
      xApiSecret: string,
      xRequestedWith: string,
      inlineObject3: InlineObject3,
      options?: any
    ): AxiosPromise<Template> {
      return localVarFp
        .sendEmailTemplate(xApiSecret, xRequestedWith, inlineObject3, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EmailsApi - object-oriented interface
 * @export
 * @class EmailsApi
 * @extends {BaseAPI}
 */
export class EmailsApi extends BaseAPI {
  /**
   * Sends an email for an entity
   * @summary Sends an email for an entity
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {InlineObject3} inlineObject3
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailsApi
   */
  public sendEmailTemplate(
    xApiSecret: string,
    xRequestedWith: string,
    inlineObject3: InlineObject3,
    options?: any
  ) {
    return EmailsApiFp(this.configuration)
      .sendEmailTemplate(xApiSecret, xRequestedWith, inlineObject3, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExpenseApi - axios parameter creator
 * @export
 */
export const ExpenseApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Handles the uploading of a document to a expense
     * @summary Uploads a document to a expense
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadExpense: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadExpense", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadExpense", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadExpense", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadExpense", "id", id);
      const localVarPath = `/api/v1/expenses/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExpenseApi - functional programming interface
 * @export
 */
export const ExpenseApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExpenseApiAxiosParamCreator(configuration);
  return {
    /**
     * Handles the uploading of a document to a expense
     * @summary Uploads a document to a expense
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ExpenseApi - factory interface
 * @export
 */
export const ExpenseApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExpenseApiFp(configuration);
  return {
    /**
     * Handles the uploading of a document to a expense
     * @summary Uploads a document to a expense
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .uploadExpense(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ExpenseApi - object-oriented interface
 * @export
 * @class ExpenseApi
 * @extends {BaseAPI}
 */
export class ExpenseApi extends BaseAPI {
  /**
   * Handles the uploading of a document to a expense
   * @summary Uploads a document to a expense
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Expense Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseApi
   */
  public uploadExpense(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ExpenseApiFp(this.configuration)
      .uploadExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExpenseCategoriesApi - axios parameter creator
 * @export
 */
export const ExpenseCategoriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of ExpenseCategorys
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Expens Categorys
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkExpenseCategorys: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkExpenseCategorys", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkExpenseCategorys", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "bulkExpenseCategorys",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkExpenseCategorys", "requestBody", requestBody);
      const localVarPath = `/api/v1/expense_categories/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an ExpenseCategory by id
     * @summary Deletes a ExpenseCategory
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExpenseCategory: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteExpenseCategory", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteExpenseCategory", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "deleteExpenseCategory",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteExpenseCategory", "id", id);
      const localVarPath = `/api/v1/expense_categories/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a Expens Category by id
     * @summary Shows a Expens Category for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editExpenseCategory: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editExpenseCategory", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editExpenseCategory", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "editExpenseCategory",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editExpenseCategory", "id", id);
      const localVarPath = `/api/v1/expense_categories/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Expens Category object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpenseCategoryCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getExpenseCategoryCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getExpenseCategoryCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getExpenseCategoryCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/expense_categories/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists tax rates
     * @summary Gets a list of expense_categories
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpenseCategorys: async (
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/expense_categories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an ExpenseCategory by id
     * @summary Shows a Expens Category
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showExpenseCategory: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showExpenseCategory", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showExpenseCategory", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "showExpenseCategory",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showExpenseCategory", "id", id);
      const localVarPath = `/api/v1/expense_categories/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a tax rate by id
     * @summary Updates a tax rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExpenseCategory: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateExpenseCategory", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateExpenseCategory", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "updateExpenseCategory",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateExpenseCategory", "id", id);
      const localVarPath = `/api/v1/expense_categories/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExpenseCategoriesApi - functional programming interface
 * @export
 */
export const ExpenseCategoriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ExpenseCategoriesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of ExpenseCategorys
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Expens Categorys
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkExpenseCategorys(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkExpenseCategorys(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an ExpenseCategory by id
     * @summary Deletes a ExpenseCategory
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteExpenseCategory(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a Expens Category by id
     * @summary Shows a Expens Category for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExpenseCategory>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editExpenseCategory(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Expens Category object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExpenseCategoryCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExpenseCategory>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getExpenseCategoryCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists tax rates
     * @summary Gets a list of expense_categories
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExpenseCategorys(
      index?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExpenseCategory>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getExpenseCategorys(index, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an ExpenseCategory by id
     * @summary Shows a Expens Category
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExpenseCategory>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showExpenseCategory(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a tax rate by id
     * @summary Updates a tax rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExpenseCategory>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateExpenseCategory(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ExpenseCategoriesApi - factory interface
 * @export
 */
export const ExpenseCategoriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExpenseCategoriesApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of ExpenseCategorys
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Expens Categorys
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkExpenseCategorys(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .bulkExpenseCategorys(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an ExpenseCategory by id
     * @summary Deletes a ExpenseCategory
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteExpenseCategory(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a Expens Category by id
     * @summary Shows a Expens Category for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<ExpenseCategory> {
      return localVarFp
        .editExpenseCategory(xApiSecret, xApiToken, xRequestedWith, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Expens Category object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpenseCategoryCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<ExpenseCategory> {
      return localVarFp
        .getExpenseCategoryCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists tax rates
     * @summary Gets a list of expense_categories
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpenseCategorys(
      index?: string,
      options?: any
    ): AxiosPromise<ExpenseCategory> {
      return localVarFp
        .getExpenseCategorys(index, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an ExpenseCategory by id
     * @summary Shows a Expens Category
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<ExpenseCategory> {
      return localVarFp
        .showExpenseCategory(xApiSecret, xApiToken, xRequestedWith, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a tax rate by id
     * @summary Updates a tax rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The ExpenseCategory Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExpenseCategory(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<ExpenseCategory> {
      return localVarFp
        .updateExpenseCategory(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ExpenseCategoriesApi - object-oriented interface
 * @export
 * @class ExpenseCategoriesApi
 * @extends {BaseAPI}
 */
export class ExpenseCategoriesApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of ExpenseCategorys
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Expens Categorys
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseCategoriesApi
   */
  public bulkExpenseCategorys(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return ExpenseCategoriesApiFp(this.configuration)
      .bulkExpenseCategorys(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an ExpenseCategory by id
   * @summary Deletes a ExpenseCategory
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ExpenseCategory Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseCategoriesApi
   */
  public deleteExpenseCategory(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return ExpenseCategoriesApiFp(this.configuration)
      .deleteExpenseCategory(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a Expens Category by id
   * @summary Shows a Expens Category for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ExpenseCategory Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseCategoriesApi
   */
  public editExpenseCategory(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return ExpenseCategoriesApiFp(this.configuration)
      .editExpenseCategory(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank Expens Category object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseCategoriesApi
   */
  public getExpenseCategoryCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    options?: any
  ) {
    return ExpenseCategoriesApiFp(this.configuration)
      .getExpenseCategoryCreate(xApiSecret, xApiToken, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists tax rates
   * @summary Gets a list of expense_categories
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseCategoriesApi
   */
  public getExpenseCategorys(index?: string, options?: any) {
    return ExpenseCategoriesApiFp(this.configuration)
      .getExpenseCategorys(index, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an ExpenseCategory by id
   * @summary Shows a Expens Category
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ExpenseCategory Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseCategoriesApi
   */
  public showExpenseCategory(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return ExpenseCategoriesApiFp(this.configuration)
      .showExpenseCategory(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a tax rate by id
   * @summary Updates a tax rate
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The ExpenseCategory Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpenseCategoriesApi
   */
  public updateExpenseCategory(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return ExpenseCategoriesApiFp(this.configuration)
      .updateExpenseCategory(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExpensesApi - axios parameter creator
 * @export
 */
export const ExpensesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of expenses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkExpenses: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkExpenses", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkExpenses", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkExpenses", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkExpenses", "requestBody", requestBody);
      const localVarPath = `/api/v1/expenses/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExpense: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteExpense", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteExpense", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteExpense", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteExpense", "id", id);
      const localVarPath = `/api/v1/expenses/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editExpense: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editExpense", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editExpense", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editExpense", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editExpense", "id", id);
      const localVarPath = `/api/v1/expenses/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists expenses, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the expenses, these are handled by the ExpenseFilters class which defines the methods available
     * @summary Gets a list of expenses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpenses: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getExpenses", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getExpenses", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getExpenses", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/expenses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpensesCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getExpensesCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getExpensesCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getExpensesCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/expenses/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showExpense: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showExpense", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showExpense", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showExpense", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showExpense", "id", id);
      const localVarPath = `/api/v1/expenses/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeExpense: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeExpense", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeExpense", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeExpense", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/expenses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExpense: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateExpense", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateExpense", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateExpense", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateExpense", "id", id);
      const localVarPath = `/api/v1/expenses/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExpensesApi - functional programming interface
 * @export
 */
export const ExpensesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExpensesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of expenses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkExpenses(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkExpenses(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists expenses, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the expenses, these are handled by the ExpenseFilters class which defines the methods available
     * @summary Gets a list of expenses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExpenses(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExpenses(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExpensesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getExpensesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Expense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ExpensesApi - factory interface
 * @export
 */
export const ExpensesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExpensesApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of expenses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkExpenses(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .bulkExpenses(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteExpense(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .editExpense(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists expenses, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the expenses, these are handled by the ExpenseFilters class which defines the methods available
     * @summary Gets a list of expenses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpenses(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .getExpenses(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExpensesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .getExpensesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .showExpense(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .storeExpense(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Expense Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateExpense(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Expense> {
      return localVarFp
        .updateExpense(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ExpensesApi - object-oriented interface
 * @export
 * @class ExpensesApi
 * @extends {BaseAPI}
 */
export class ExpensesApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of expenses
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public bulkExpenses(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .bulkExpenses(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a client by id
   * @summary Deletes a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Expense Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public deleteExpense(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .deleteExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Expense Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public editExpense(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .editExpense(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists expenses, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the expenses, these are handled by the ExpenseFilters class which defines the methods available
   * @summary Gets a list of expenses
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public getExpenses(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .getExpenses(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank client object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public getExpensesCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .getExpensesCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Expense Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public showExpense(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .showExpense(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an client to a company
   * @summary Adds a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public storeExpense(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .storeExpense(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a client by id
   * @summary Updates a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Expense Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExpensesApi
   */
  public updateExpense(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ExpensesApiFp(this.configuration)
      .updateExpense(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Export data from the system
     * @summary Export data from the system
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExport: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getExport", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getExport", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/export`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration);
  return {
    /**
     * Export data from the system
     * @summary Export data from the system
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExport(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getExport(
        xApiSecret,
        xRequestedWith,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExportApiFp(configuration);
  return {
    /**
     * Export data from the system
     * @summary Export data from the system
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExport(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getExport(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
  /**
   * Export data from the system
   * @summary Export data from the system
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExportApi
   */
  public getExport(xApiSecret: string, xRequestedWith: string, options?: any) {
    return ExportApiFp(this.configuration)
      .getExport(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GroupSettingsApi - axios parameter creator
 * @export
 */
export const GroupSettingsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of group_settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody An array of group_settings ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkGroupSettings: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkGroupSettings", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkGroupSettings", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkGroupSettings", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkGroupSettings", "requestBody", requestBody);
      const localVarPath = `/api/v1/group_settings/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an GroupSetting by id
     * @summary Deletes a GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupSetting: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteGroupSetting", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteGroupSetting", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteGroupSetting", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteGroupSetting", "id", id);
      const localVarPath = `/api/v1/group_settings/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an GroupSetting by id
     * @summary Shows an GroupSetting for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editGroupSetting: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editGroupSetting", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editGroupSetting", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editGroupSetting", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editGroupSetting", "id", id);
      const localVarPath = `/api/v1/group_settings/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists group_settings, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the group_settings, these are handled by the GroupSettingFilters class which defines the methods available
     * @summary Gets a list of group_settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupSettings: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getGroupSettings", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getGroupSettings", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getGroupSettings", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/group_settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank GroupSetting object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupSettingsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getGroupSettingsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getGroupSettingsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getGroupSettingsCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/group_settings/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an GroupSetting by id
     * @summary Shows an GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showGroupSetting: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showGroupSetting", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showGroupSetting", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showGroupSetting", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showGroupSetting", "id", id);
      const localVarPath = `/api/v1/group_settings/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an GroupSetting to the system
     * @summary Adds a GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeGroupSetting: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeGroupSetting", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeGroupSetting", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeGroupSetting", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/group_settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an GroupSetting by id
     * @summary Updates an GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupSetting: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateGroupSetting", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateGroupSetting", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateGroupSetting", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateGroupSetting", "id", id);
      const localVarPath = `/api/v1/group_settings/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GroupSettingsApi - functional programming interface
 * @export
 */
export const GroupSettingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    GroupSettingsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of group_settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody An array of group_settings ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkGroupSettings(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkGroupSettings(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an GroupSetting by id
     * @summary Deletes a GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an GroupSetting by id
     * @summary Shows an GroupSetting for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists group_settings, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the group_settings, these are handled by the GroupSettingFilters class which defines the methods available
     * @summary Gets a list of group_settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroupSettings(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGroupSettings(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank GroupSetting object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroupSettingsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGroupSettingsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an GroupSetting by id
     * @summary Shows an GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an GroupSetting to the system
     * @summary Adds a GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.storeGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an GroupSetting by id
     * @summary Updates an GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSetting>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * GroupSettingsApi - factory interface
 * @export
 */
export const GroupSettingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GroupSettingsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of group_settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody An array of group_settings ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkGroupSettings(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .bulkGroupSettings(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an GroupSetting by id
     * @summary Deletes a GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an GroupSetting by id
     * @summary Shows an GroupSetting for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<GroupSetting> {
      return localVarFp
        .editGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists group_settings, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the group_settings, these are handled by the GroupSettingFilters class which defines the methods available
     * @summary Gets a list of group_settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupSettings(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<GroupSetting> {
      return localVarFp
        .getGroupSettings(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank GroupSetting object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupSettingsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<GroupSetting> {
      return localVarFp
        .getGroupSettingsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an GroupSetting by id
     * @summary Shows an GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<GroupSetting> {
      return localVarFp
        .showGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an GroupSetting to the system
     * @summary Adds a GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<GroupSetting> {
      return localVarFp
        .storeGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an GroupSetting by id
     * @summary Updates an GroupSetting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The GroupSetting Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupSetting(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<GroupSetting> {
      return localVarFp
        .updateGroupSetting(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GroupSettingsApi - object-oriented interface
 * @export
 * @class GroupSettingsApi
 * @extends {BaseAPI}
 */
export class GroupSettingsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of group_settings
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody An array of group_settings ids
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public bulkGroupSettings(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .bulkGroupSettings(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an GroupSetting by id
   * @summary Deletes a GroupSetting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The GroupSetting Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public deleteGroupSetting(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .deleteGroupSetting(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an GroupSetting by id
   * @summary Shows an GroupSetting for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The GroupSetting Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public editGroupSetting(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .editGroupSetting(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists group_settings, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the group_settings, these are handled by the GroupSettingFilters class which defines the methods available
   * @summary Gets a list of group_settings
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public getGroupSettings(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .getGroupSettings(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank GroupSetting object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public getGroupSettingsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .getGroupSettingsCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an GroupSetting by id
   * @summary Shows an GroupSetting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The GroupSetting Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public showGroupSetting(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .showGroupSetting(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an GroupSetting to the system
   * @summary Adds a GroupSetting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public storeGroupSetting(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .storeGroupSetting(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an GroupSetting by id
   * @summary Updates an GroupSetting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The GroupSetting Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupSettingsApi
   */
  public updateGroupSetting(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return GroupSettingsApiFp(this.configuration)
      .updateGroupSetting(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Attempts to get a health check from the API
     * @summary Attempts to get a health check from the API
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealthCheck: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getHealthCheck", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getHealthCheck", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/health_check`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    HealthCheckApiAxiosParamCreator(configuration);
  return {
    /**
     * Attempts to get a health check from the API
     * @summary Attempts to get a health check from the API
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHealthCheck(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthCheck(
        xApiSecret,
        xRequestedWith,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HealthCheckApiFp(configuration);
  return {
    /**
     * Attempts to get a health check from the API
     * @summary Attempts to get a health check from the API
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHealthCheck(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getHealthCheck(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
  /**
   * Attempts to get a health check from the API
   * @summary Attempts to get a health check from the API
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthCheckApi
   */
  public getHealthCheck(
    xApiSecret: string,
    xRequestedWith: string,
    options?: any
  ) {
    return HealthCheckApiFp(this.configuration)
      .getHealthCheck(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ImportApi - axios parameter creator
 * @export
 */
export const ImportApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Import data from the system
     * @summary Import data from the system
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImportJson: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getImportJson", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getImportJson", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/import_json`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImportApiAxiosParamCreator(configuration);
  return {
    /**
     * Import data from the system
     * @summary Import data from the system
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getImportJson(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getImportJson(
        xApiSecret,
        xRequestedWith,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ImportApiFp(configuration);
  return {
    /**
     * Import data from the system
     * @summary Import data from the system
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImportJson(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getImportJson(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
  /**
   * Import data from the system
   * @summary Import data from the system
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImportApi
   */
  public getImportJson(
    xApiSecret: string,
    xRequestedWith: string,
    options?: any
  ) {
    return ImportApiFp(this.configuration)
      .getImportJson(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ImportsApi - axios parameter creator
 * @export
 */
export const ImportsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Pre Import checks - returns a reference to the job and the headers of the CSV
     * @summary Pre Import checks - returns a reference to the job and the headers of the CSV
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    preimport: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("preimport", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("preimport", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("preimport", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/preimport`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImportsApi - functional programming interface
 * @export
 */
export const ImportsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImportsApiAxiosParamCreator(configuration);
  return {
    /**
     * Pre Import checks - returns a reference to the job and the headers of the CSV
     * @summary Pre Import checks - returns a reference to the job and the headers of the CSV
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async preimport(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.preimport(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ImportsApi - factory interface
 * @export
 */
export const ImportsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ImportsApiFp(configuration);
  return {
    /**
     * Pre Import checks - returns a reference to the job and the headers of the CSV
     * @summary Pre Import checks - returns a reference to the job and the headers of the CSV
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    preimport(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .preimport(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ImportsApi - object-oriented interface
 * @export
 * @class ImportsApi
 * @extends {BaseAPI}
 */
export class ImportsApi extends BaseAPI {
  /**
   * Pre Import checks - returns a reference to the job and the headers of the CSV
   * @summary Pre Import checks - returns a reference to the job and the headers of the CSV
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImportsApi
   */
  public preimport(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ImportsApiFp(this.configuration)
      .preimport(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Performs a custom action on an invoice.      *      *        The current range of actions are as follows      *        - clone_to_invoice      *        - clone_to_quote      *        - history      *        - delivery_note      *        - mark_paid      *        - download      *        - archive      *        - delete      *        - email
     * @summary Performs a custom action on an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("actionInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("actionInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("actionInvoice", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("actionInvoice", "id", id);
      // verify required parameter 'action' is not null or undefined
      assertParamExists("actionInvoice", "action", action);
      const localVarPath = `/api/v1/invoices/{id}/{action}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"action"}}`, encodeURIComponent(String(action)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Performs bulk actions on an array of invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkInvoices: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkInvoices", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkInvoices", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkInvoices", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkInvoices", "requestBody", requestBody);
      const localVarPath = `/api/v1/invoices/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an invoice by id
     * @summary Deletes a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteInvoice", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteInvoice", "id", id);
      const localVarPath = `/api/v1/invoices/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads a specific invoice delivery notes
     * @summary Download a specific invoice delivery notes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hahsed Id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deliveryNote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deliveryNote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deliveryNote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deliveryNote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deliveryNote", "id", id);
      const localVarPath = `/api/v1/invoices/{id}/delivery_note`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads a specific invoice
     * @summary Download a specific invoice by invitation key
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} invitationKey The Invoice Invitation Key
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      invitationKey: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("downloadInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("downloadInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("downloadInvoice", "xRequestedWith", xRequestedWith);
      // verify required parameter 'invitationKey' is not null or undefined
      assertParamExists("downloadInvoice", "invitationKey", invitationKey);
      const localVarPath = `/api/v1/invoice/{invitation_key}/download`.replace(
        `{${"invitation_key"}}`,
        encodeURIComponent(String(invitationKey))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads a specific invoice
     * @summary Download a specific invoice by invitation key
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} invitationKey The Recurring Invoice Invitation Key
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      invitationKey: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("downloadRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("downloadRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "downloadRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'invitationKey' is not null or undefined
      assertParamExists(
        "downloadRecurringInvoice",
        "invitationKey",
        invitationKey
      );
      const localVarPath =
        `/api/v1/recurring_invoice/{invitation_key}/download`.replace(
          `{${"invitation_key"}}`,
          encodeURIComponent(String(invitationKey))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an invoice by id
     * @summary Shows an invoice for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editInvoice", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editInvoice", "id", id);
      const localVarPath = `/api/v1/invoices/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists invoices, search and filters allow fine grained lists to be generated.      *      *  Query parameters can be added to performed more fine grained filtering of the invoices, these are handled by the InvoiceFilters class which defines the methods available
     * @summary Gets a list of invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoices: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getInvoices", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getInvoices", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getInvoices", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/invoices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank invoice object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoicesCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getInvoicesCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getInvoicesCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getInvoicesCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/invoices/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an invoice by id
     * @summary Shows an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showInvoice", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showInvoice", "id", id);
      const localVarPath = `/api/v1/invoices/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an invoice to the system
     * @summary Adds a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeInvoice", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/invoices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an invoice by id
     * @summary Updates an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateInvoice", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateInvoice", "id", id);
      const localVarPath = `/api/v1/invoices/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a invoice
     * @summary Uploads a document to a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadInvoice", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadInvoice", "id", id);
      const localVarPath = `/api/v1/invoices/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration);
  return {
    /**
     * Performs a custom action on an invoice.      *      *        The current range of actions are as follows      *        - clone_to_invoice      *        - clone_to_quote      *        - history      *        - delivery_note      *        - mark_paid      *        - download      *        - archive      *        - delete      *        - email
     * @summary Performs a custom action on an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async actionInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.actionInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Performs bulk actions on an array of invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkInvoices(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an invoice by id
     * @summary Deletes a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Downloads a specific invoice delivery notes
     * @summary Download a specific invoice delivery notes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hahsed Id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deliveryNote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryNote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Downloads a specific invoice
     * @summary Download a specific invoice by invitation key
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} invitationKey The Invoice Invitation Key
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      invitationKey: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        invitationKey,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Downloads a specific invoice
     * @summary Download a specific invoice by invitation key
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} invitationKey The Recurring Invoice Invitation Key
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      invitationKey: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.downloadRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          invitationKey,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an invoice by id
     * @summary Shows an invoice for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists invoices, search and filters allow fine grained lists to be generated.      *      *  Query parameters can be added to performed more fine grained filtering of the invoices, these are handled by the InvoiceFilters class which defines the methods available
     * @summary Gets a list of invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoices(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank invoice object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInvoicesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInvoicesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an invoice by id
     * @summary Shows an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an invoice to the system
     * @summary Adds a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an invoice by id
     * @summary Updates an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a invoice
     * @summary Uploads a document to a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = InvoicesApiFp(configuration);
  return {
    /**
     * Performs a custom action on an invoice.      *      *        The current range of actions are as follows      *        - clone_to_invoice      *        - clone_to_quote      *        - history      *        - delivery_note      *        - mark_paid      *        - download      *        - archive      *        - delete      *        - email
     * @summary Performs a custom action on an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .actionInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          action,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Performs bulk actions on an array of invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .bulkInvoices(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an invoice by id
     * @summary Deletes a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads a specific invoice delivery notes
     * @summary Download a specific invoice delivery notes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hahsed Id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deliveryNote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deliveryNote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads a specific invoice
     * @summary Download a specific invoice by invitation key
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} invitationKey The Invoice Invitation Key
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      invitationKey: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          invitationKey,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads a specific invoice
     * @summary Download a specific invoice by invitation key
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} invitationKey The Recurring Invoice Invitation Key
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      invitationKey: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .downloadRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          invitationKey,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an invoice by id
     * @summary Shows an invoice for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .editInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists invoices, search and filters allow fine grained lists to be generated.      *      *  Query parameters can be added to performed more fine grained filtering of the invoices, these are handled by the InvoiceFilters class which defines the methods available
     * @summary Gets a list of invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .getInvoices(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank invoice object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInvoicesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .getInvoicesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an invoice by id
     * @summary Shows an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .showInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an invoice to the system
     * @summary Adds a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .storeInvoice(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an invoice by id
     * @summary Updates an invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .updateInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a invoice
     * @summary Uploads a document to a invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Invoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Invoice> {
      return localVarFp
        .uploadInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
  /**
   * Performs a custom action on an invoice.      *      *        The current range of actions are as follows      *        - clone_to_invoice      *        - clone_to_quote      *        - history      *        - delivery_note      *        - mark_paid      *        - download      *        - archive      *        - delete      *        - email
   * @summary Performs a custom action on an invoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hashed ID
   * @param {string} action The action string to be performed
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public actionInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    action: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .actionInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Performs bulk actions on an array of invoices
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public bulkInvoices(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .bulkInvoices(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an invoice by id
   * @summary Deletes a invoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public deleteInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .deleteInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Downloads a specific invoice delivery notes
   * @summary Download a specific invoice delivery notes
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hahsed Id
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public deliveryNote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .deliveryNote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Downloads a specific invoice
   * @summary Download a specific invoice by invitation key
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} invitationKey The Invoice Invitation Key
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public downloadInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    invitationKey: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .downloadInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        invitationKey,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Downloads a specific invoice
   * @summary Download a specific invoice by invitation key
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} invitationKey The Recurring Invoice Invitation Key
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public downloadRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    invitationKey: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .downloadRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        invitationKey,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an invoice by id
   * @summary Shows an invoice for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public editInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .editInvoice(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists invoices, search and filters allow fine grained lists to be generated.      *      *  Query parameters can be added to performed more fine grained filtering of the invoices, these are handled by the InvoiceFilters class which defines the methods available
   * @summary Gets a list of invoices
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public getInvoices(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .getInvoices(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank invoice object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public getInvoicesCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .getInvoicesCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an invoice by id
   * @summary Shows an invoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public showInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .showInvoice(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an invoice to the system
   * @summary Adds a invoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public storeInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .storeInvoice(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an invoice by id
   * @summary Updates an invoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public updateInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .updateInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a invoice
   * @summary Uploads a document to a invoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Invoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InvoicesApi
   */
  public uploadInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return InvoicesApiFp(this.configuration)
      .uploadInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a CompanyUser object on success
     * @summary Attempts authentication
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject1} inlineObject1
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLogin: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      inlineObject1: InlineObject1,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("postLogin", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("postLogin", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("postLogin", "xRequestedWith", xRequestedWith);
      // verify required parameter 'inlineObject1' is not null or undefined
      assertParamExists("postLogin", "inlineObject1", inlineObject1);
      const localVarPath = `/api/v1/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (includeStatic !== undefined) {
        localVarQueryParameter["include_static"] = includeStatic;
      }

      if (clearCache !== undefined) {
        localVarQueryParameter["clear_cache"] = clearCache;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject1,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a CompanyUser object on success
     * @summary Attempts authentication
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject1} inlineObject1
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLogin(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      inlineObject1: InlineObject1,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postLogin(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        inlineObject1,
        include,
        includeStatic,
        clearCache,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LoginApiFp(configuration);
  return {
    /**
     * Returns a CompanyUser object on success
     * @summary Attempts authentication
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject1} inlineObject1
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLogin(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      inlineObject1: InlineObject1,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options?: any
    ): AxiosPromise<CompanyUser> {
      return localVarFp
        .postLogin(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          inlineObject1,
          include,
          includeStatic,
          clearCache,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
  /**
   * Returns a CompanyUser object on success
   * @summary Attempts authentication
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {InlineObject1} inlineObject1
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [includeStatic] Returns static variables
   * @param {string} [clearCache] Clears the static cache
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoginApi
   */
  public postLogin(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    inlineObject1: InlineObject1,
    include?: string,
    includeStatic?: string,
    clearCache?: string,
    options?: any
  ) {
    return LoginApiFp(this.configuration)
      .postLogin(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        inlineObject1,
        include,
        includeStatic,
        clearCache,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LogoutApi - axios parameter creator
 * @export
 */
export const LogoutApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists all logout
     * @summary Gets a list of logout
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogout: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getLogout", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getLogout", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getLogout", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LogoutApi - functional programming interface
 * @export
 */
export const LogoutApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LogoutApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists all logout
     * @summary Gets a list of logout
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogout(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogout(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LogoutApi - factory interface
 * @export
 */
export const LogoutApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LogoutApiFp(configuration);
  return {
    /**
     * Lists all logout
     * @summary Gets a list of logout
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogout(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getLogout(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LogoutApi - object-oriented interface
 * @export
 * @class LogoutApi
 * @extends {BaseAPI}
 */
export class LogoutApi extends BaseAPI {
  /**
   * Lists all logout
   * @summary Gets a list of logout
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LogoutApi
   */
  public getLogout(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return LogoutApiFp(this.configuration)
      .getLogout(xApiSecret, xApiToken, xRequestedWith, include, index, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MigrationApi - axios parameter creator
 * @export
 */
export const MigrationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Attempts to purge a company record and all its child records
     * @summary Attempts to purge a company record and all its child records
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} company The Company Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPurgeCompany: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      company: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("postPurgeCompany", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("postPurgeCompany", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("postPurgeCompany", "xRequestedWith", xRequestedWith);
      // verify required parameter 'company' is not null or undefined
      assertParamExists("postPurgeCompany", "company", company);
      const localVarPath = `/api/v1/migration/purge/{company}`.replace(
        `{${"company"}}`,
        encodeURIComponent(String(company))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Attempts to purge a companies child records but save the company record and its settings
     * @summary Attempts to purge a companies child records but save the company record and its settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} company The Company Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPurgeCompanySaveSettings: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      company: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists(
        "postPurgeCompanySaveSettings",
        "xApiSecret",
        xApiSecret
      );
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("postPurgeCompanySaveSettings", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "postPurgeCompanySaveSettings",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'company' is not null or undefined
      assertParamExists("postPurgeCompanySaveSettings", "company", company);
      const localVarPath =
        `/api/v1/migration/purge_save_settings/{company}`.replace(
          `{${"company"}}`,
          encodeURIComponent(String(company))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Starts the migration from previous version of Invoice Ninja
     * @summary Starts the migration from previous version of Invoice Ninja
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} xApiPassword The login password when challenged
     * @param {object} migration The migraton file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postStartMigration: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      xApiPassword: string,
      migration: object,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("postStartMigration", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("postStartMigration", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("postStartMigration", "xRequestedWith", xRequestedWith);
      // verify required parameter 'xApiPassword' is not null or undefined
      assertParamExists("postStartMigration", "xApiPassword", xApiPassword);
      // verify required parameter 'migration' is not null or undefined
      assertParamExists("postStartMigration", "migration", migration);
      const localVarPath = `/api/v1/migration/start`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (migration !== undefined) {
        localVarQueryParameter["migration"] = migration;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      if (xApiPassword !== undefined && xApiPassword !== null) {
        localVarHeaderParameter["X-Api-Password"] = String(xApiPassword);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MigrationApi - functional programming interface
 * @export
 */
export const MigrationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MigrationApiAxiosParamCreator(configuration);
  return {
    /**
     * Attempts to purge a company record and all its child records
     * @summary Attempts to purge a company record and all its child records
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} company The Company Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postPurgeCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      company: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postPurgeCompany(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          company,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Attempts to purge a companies child records but save the company record and its settings
     * @summary Attempts to purge a companies child records but save the company record and its settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} company The Company Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postPurgeCompanySaveSettings(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      company: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postPurgeCompanySaveSettings(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          company,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Starts the migration from previous version of Invoice Ninja
     * @summary Starts the migration from previous version of Invoice Ninja
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} xApiPassword The login password when challenged
     * @param {object} migration The migraton file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postStartMigration(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      xApiPassword: string,
      migration: object,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postStartMigration(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          xApiPassword,
          migration,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * MigrationApi - factory interface
 * @export
 */
export const MigrationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MigrationApiFp(configuration);
  return {
    /**
     * Attempts to purge a company record and all its child records
     * @summary Attempts to purge a company record and all its child records
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} company The Company Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPurgeCompany(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      company: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postPurgeCompany(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          company,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Attempts to purge a companies child records but save the company record and its settings
     * @summary Attempts to purge a companies child records but save the company record and its settings
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} company The Company Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postPurgeCompanySaveSettings(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      company: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postPurgeCompanySaveSettings(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          company,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Starts the migration from previous version of Invoice Ninja
     * @summary Starts the migration from previous version of Invoice Ninja
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} xApiPassword The login password when challenged
     * @param {object} migration The migraton file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postStartMigration(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      xApiPassword: string,
      migration: object,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postStartMigration(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          xApiPassword,
          migration,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MigrationApi - object-oriented interface
 * @export
 * @class MigrationApi
 * @extends {BaseAPI}
 */
export class MigrationApi extends BaseAPI {
  /**
   * Attempts to purge a company record and all its child records
   * @summary Attempts to purge a company record and all its child records
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} company The Company Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MigrationApi
   */
  public postPurgeCompany(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    company: string,
    options?: any
  ) {
    return MigrationApiFp(this.configuration)
      .postPurgeCompany(xApiSecret, xApiToken, xRequestedWith, company, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Attempts to purge a companies child records but save the company record and its settings
   * @summary Attempts to purge a companies child records but save the company record and its settings
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} company The Company Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MigrationApi
   */
  public postPurgeCompanySaveSettings(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    company: string,
    options?: any
  ) {
    return MigrationApiFp(this.configuration)
      .postPurgeCompanySaveSettings(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        company,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Starts the migration from previous version of Invoice Ninja
   * @summary Starts the migration from previous version of Invoice Ninja
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} xApiPassword The login password when challenged
   * @param {object} migration The migraton file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MigrationApi
   */
  public postStartMigration(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    xApiPassword: string,
    migration: object,
    options?: any
  ) {
    return MigrationApiFp(this.configuration)
      .postStartMigration(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        xApiPassword,
        migration,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OneTimeTokenApi - axios parameter creator
 * @export
 */
export const OneTimeTokenApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Attempts to create a one time token
     * @summary Attempts to create a one time token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oneTimeToken: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("oneTimeToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("oneTimeToken", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/one_time_token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OneTimeTokenApi - functional programming interface
 * @export
 */
export const OneTimeTokenApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OneTimeTokenApiAxiosParamCreator(configuration);
  return {
    /**
     * Attempts to create a one time token
     * @summary Attempts to create a one time token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oneTimeToken(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oneTimeToken(
        xApiSecret,
        xRequestedWith,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * OneTimeTokenApi - factory interface
 * @export
 */
export const OneTimeTokenApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OneTimeTokenApiFp(configuration);
  return {
    /**
     * Attempts to create a one time token
     * @summary Attempts to create a one time token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oneTimeToken(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .oneTimeToken(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OneTimeTokenApi - object-oriented interface
 * @export
 * @class OneTimeTokenApi
 * @extends {BaseAPI}
 */
export class OneTimeTokenApi extends BaseAPI {
  /**
   * Attempts to create a one time token
   * @summary Attempts to create a one time token
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OneTimeTokenApi
   */
  public oneTimeToken(
    xApiSecret: string,
    xRequestedWith: string,
    options?: any
  ) {
    return OneTimeTokenApiFp(this.configuration)
      .oneTimeToken(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PaymentTermsApi - axios parameter creator
 * @export
 */
export const PaymentTermsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of payment terms
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Payment Ter,s
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkPaymentTerms: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkPaymentTerms", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkPaymentTerms", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkPaymentTerms", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkPaymentTerms", "requestBody", requestBody);
      const localVarPath = `/api/v1/payment_terms/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Payment Term by id
     * @summary Shows an Payment Term for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPaymentTerms: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editPaymentTerms", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editPaymentTerms", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editPaymentTerms", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editPaymentTerms", "id", id);
      const localVarPath = `/api/v1/payment_terms/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists payment terms
     * @summary Gets a list of payment terms
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentTerms: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getPaymentTerms", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getPaymentTerms", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getPaymentTerms", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/payment_terms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank PaymentTerm object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentTermsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getPaymentTermsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getPaymentTermsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getPaymentTermsCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/payment_terms/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Payment Term by id
     * @summary Shows a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showPaymentTerm: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showPaymentTerm", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showPaymentTerm", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showPaymentTerm", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showPaymentTerm", "id", id);
      const localVarPath = `/api/v1/payment_terms/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds a Payment Term to the system
     * @summary Adds a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {PaymentTerm} paymentTerm The payment_terms request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storePaymentTerm: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      paymentTerm: PaymentTerm,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storePaymentTerm", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storePaymentTerm", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storePaymentTerm", "xRequestedWith", xRequestedWith);
      // verify required parameter 'paymentTerm' is not null or undefined
      assertParamExists("storePaymentTerm", "paymentTerm", paymentTerm);
      const localVarPath = `/api/v1/payment_terms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        paymentTerm,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an Payment Termby id
     * @summary Updates a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentTerm: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updatePaymentTerm", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updatePaymentTerm", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updatePaymentTerm", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updatePaymentTerm", "id", id);
      const localVarPath = `/api/v1/payment_terms/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PaymentTermsApi - functional programming interface
 * @export
 */
export const PaymentTermsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PaymentTermsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of payment terms
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Payment Ter,s
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkPaymentTerms(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTerm>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkPaymentTerms(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Payment Term by id
     * @summary Shows an Payment Term for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editPaymentTerms(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTerm>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editPaymentTerms(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists payment terms
     * @summary Gets a list of payment terms
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentTerms(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTerm>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentTerms(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank PaymentTerm object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentTermsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPaymentTermsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Payment Term by id
     * @summary Shows a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showPaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTerm>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showPaymentTerm(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds a Payment Term to the system
     * @summary Adds a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {PaymentTerm} paymentTerm The payment_terms request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storePaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      paymentTerm: PaymentTerm,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTerm>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.storePaymentTerm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          paymentTerm,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an Payment Termby id
     * @summary Updates a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTerm>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePaymentTerm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PaymentTermsApi - factory interface
 * @export
 */
export const PaymentTermsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PaymentTermsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of payment terms
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Payment Ter,s
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkPaymentTerms(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<PaymentTerm> {
      return localVarFp
        .bulkPaymentTerms(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Payment Term by id
     * @summary Shows an Payment Term for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPaymentTerms(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<PaymentTerm> {
      return localVarFp
        .editPaymentTerms(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists payment terms
     * @summary Gets a list of payment terms
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentTerms(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<PaymentTerm> {
      return localVarFp
        .getPaymentTerms(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank PaymentTerm object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentTermsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .getPaymentTermsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Payment Term by id
     * @summary Shows a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showPaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<PaymentTerm> {
      return localVarFp
        .showPaymentTerm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a Payment Term to the system
     * @summary Adds a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {PaymentTerm} paymentTerm The payment_terms request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storePaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      paymentTerm: PaymentTerm,
      include?: string,
      options?: any
    ): AxiosPromise<PaymentTerm> {
      return localVarFp
        .storePaymentTerm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          paymentTerm,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an Payment Termby id
     * @summary Updates a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<PaymentTerm> {
      return localVarFp
        .updatePaymentTerm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PaymentTermsApi - object-oriented interface
 * @export
 * @class PaymentTermsApi
 * @extends {BaseAPI}
 */
export class PaymentTermsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of payment terms
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Payment Ter,s
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermsApi
   */
  public bulkPaymentTerms(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return PaymentTermsApiFp(this.configuration)
      .bulkPaymentTerms(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Payment Term by id
   * @summary Shows an Payment Term for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Term Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermsApi
   */
  public editPaymentTerms(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentTermsApiFp(this.configuration)
      .editPaymentTerms(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists payment terms
   * @summary Gets a list of payment terms
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermsApi
   */
  public getPaymentTerms(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return PaymentTermsApiFp(this.configuration)
      .getPaymentTerms(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank PaymentTerm object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermsApi
   */
  public getPaymentTermsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return PaymentTermsApiFp(this.configuration)
      .getPaymentTermsCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Payment Term by id
   * @summary Shows a Payment Term
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Term Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermsApi
   */
  public showPaymentTerm(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentTermsApiFp(this.configuration)
      .showPaymentTerm(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a Payment Term to the system
   * @summary Adds a Payment
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {PaymentTerm} paymentTerm The payment_terms request
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermsApi
   */
  public storePaymentTerm(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    paymentTerm: PaymentTerm,
    include?: string,
    options?: any
  ) {
    return PaymentTermsApiFp(this.configuration)
      .storePaymentTerm(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        paymentTerm,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an Payment Termby id
   * @summary Updates a Payment Term
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Term Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermsApi
   */
  public updatePaymentTerm(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentTermsApiFp(this.configuration)
      .updatePaymentTerm(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PaymentTermssApi - axios parameter creator
 * @export
 */
export const PaymentTermssApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Handles the deletion of an PaymentTerm by id
     * @summary Deletes a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentTerm: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deletePaymentTerm", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deletePaymentTerm", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deletePaymentTerm", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deletePaymentTerm", "id", id);
      const localVarPath = `/api/v1/payment_terms/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PaymentTermssApi - functional programming interface
 * @export
 */
export const PaymentTermssApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PaymentTermssApiAxiosParamCreator(configuration);
  return {
    /**
     * Handles the deletion of an PaymentTerm by id
     * @summary Deletes a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePaymentTerm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PaymentTermssApi - factory interface
 * @export
 */
export const PaymentTermssApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PaymentTermssApiFp(configuration);
  return {
    /**
     * Handles the deletion of an PaymentTerm by id
     * @summary Deletes a Payment Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Term Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePaymentTerm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deletePaymentTerm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PaymentTermssApi - object-oriented interface
 * @export
 * @class PaymentTermssApi
 * @extends {BaseAPI}
 */
export class PaymentTermssApi extends BaseAPI {
  /**
   * Handles the deletion of an PaymentTerm by id
   * @summary Deletes a Payment Term
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Term Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentTermssApi
   */
  public deletePaymentTerm(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentTermssApiFp(this.configuration)
      .deletePaymentTerm(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Performs a custom action on an Payment.      The current range of actions are as follows     - clone_to_Payment     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionPayment: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("actionPayment", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("actionPayment", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("actionPayment", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("actionPayment", "id", id);
      // verify required parameter 'action' is not null or undefined
      assertParamExists("actionPayment", "action", action);
      const localVarPath = `/api/v1/payments/{id}/{action}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"action"}}`, encodeURIComponent(String(action)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Performs bulk actions on an array of payments
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkPayments: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkPayments", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkPayments", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkPayments", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkPayments", "requestBody", requestBody);
      const localVarPath = `/api/v1/payments/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an Payment by id
     * @summary Deletes a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePayment: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deletePayment", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deletePayment", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deletePayment", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deletePayment", "id", id);
      const localVarPath = `/api/v1/payments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Payment by id
     * @summary Shows an Payment for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPayment: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editPayment", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editPayment", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editPayment", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editPayment", "id", id);
      const localVarPath = `/api/v1/payments/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists payments, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the payments, these are handled by the PaymentFilters class which defines the methods available
     * @summary Gets a list of payments
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayments: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getPayments", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getPayments", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getPayments", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Payment object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getPaymentsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getPaymentsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getPaymentsCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/payments/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Payment by id
     * @summary Shows an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showPayment: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showPayment", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showPayment", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showPayment", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showPayment", "id", id);
      const localVarPath = `/api/v1/payments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an Payment to the system
     * @summary Adds a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Payment} payment The payment request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storePayment: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      payment: Payment,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storePayment", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storePayment", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storePayment", "xRequestedWith", xRequestedWith);
      // verify required parameter 'payment' is not null or undefined
      assertParamExists("storePayment", "payment", payment);
      const localVarPath = `/api/v1/payments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        payment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an Refund to the system
     * @summary Adds a Refund
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Payment} payment The refund request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeRefund: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      payment: Payment,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeRefund", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeRefund", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeRefund", "xRequestedWith", xRequestedWith);
      // verify required parameter 'payment' is not null or undefined
      assertParamExists("storeRefund", "payment", payment);
      const localVarPath = `/api/v1/payments/refund`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        payment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an Payment by id
     * @summary Updates an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePayment: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updatePayment", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updatePayment", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updatePayment", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updatePayment", "id", id);
      const localVarPath = `/api/v1/payments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a payment
     * @summary Uploads a document to a payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPayment: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadPayment", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadPayment", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadPayment", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadPayment", "id", id);
      const localVarPath = `/api/v1/payments/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Performs a custom action on an Payment.      The current range of actions are as follows     - clone_to_Payment     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async actionPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.actionPayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Performs bulk actions on an array of payments
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkPayments(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkPayments(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an Payment by id
     * @summary Deletes a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Payment by id
     * @summary Shows an Payment for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editPayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists payments, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the payments, these are handled by the PaymentFilters class which defines the methods available
     * @summary Gets a list of payments
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPayments(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPayments(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Payment object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPaymentsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPaymentsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Payment by id
     * @summary Shows an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showPayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an Payment to the system
     * @summary Adds a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Payment} payment The payment request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storePayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      payment: Payment,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storePayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        payment,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an Refund to the system
     * @summary Adds a Refund
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Payment} payment The refund request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeRefund(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      payment: Payment,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeRefund(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        payment,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an Payment by id
     * @summary Updates an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a payment
     * @summary Uploads a document to a payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PaymentsApiFp(configuration);
  return {
    /**
     * Performs a custom action on an Payment.      The current range of actions are as follows     - clone_to_Payment     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .actionPayment(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          action,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Performs bulk actions on an array of payments
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkPayments(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .bulkPayments(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an Payment by id
     * @summary Deletes a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deletePayment(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Payment by id
     * @summary Shows an Payment for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .editPayment(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists payments, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the payments, these are handled by the PaymentFilters class which defines the methods available
     * @summary Gets a list of payments
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayments(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .getPayments(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Payment object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPaymentsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .getPaymentsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Payment by id
     * @summary Shows an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .showPayment(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an Payment to the system
     * @summary Adds a Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Payment} payment The payment request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storePayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      payment: Payment,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .storePayment(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          payment,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an Refund to the system
     * @summary Adds a Refund
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Payment} payment The refund request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeRefund(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      payment: Payment,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .storeRefund(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          payment,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an Payment by id
     * @summary Updates an Payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .updatePayment(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a payment
     * @summary Uploads a document to a payment
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Payment Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPayment(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Payment> {
      return localVarFp
        .uploadPayment(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
  /**
   * Performs a custom action on an Payment.      The current range of actions are as follows     - clone_to_Payment     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
   * @summary Performs a custom action on an Payment
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Hashed ID
   * @param {string} action The action string to be performed
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public actionPayment(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    action: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .actionPayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Performs bulk actions on an array of payments
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public bulkPayments(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .bulkPayments(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an Payment by id
   * @summary Deletes a Payment
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public deletePayment(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .deletePayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Payment by id
   * @summary Shows an Payment for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public editPayment(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .editPayment(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists payments, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the payments, these are handled by the PaymentFilters class which defines the methods available
   * @summary Gets a list of payments
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public getPayments(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .getPayments(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank Payment object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public getPaymentsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .getPaymentsCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Payment by id
   * @summary Shows an Payment
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public showPayment(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .showPayment(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an Payment to the system
   * @summary Adds a Payment
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Payment} payment The payment request
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public storePayment(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    payment: Payment,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .storePayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        payment,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an Refund to the system
   * @summary Adds a Refund
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Payment} payment The refund request
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public storeRefund(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    payment: Payment,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .storeRefund(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        payment,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an Payment by id
   * @summary Updates an Payment
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public updatePayment(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .updatePayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a payment
   * @summary Uploads a document to a payment
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Payment Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public uploadPayment(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration)
      .uploadPayment(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PingApi - axios parameter creator
 * @export
 */
export const PingApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Attempts to ping the API
     * @summary Attempts to ping the API
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPing: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getPing", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getPing", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PingApi - functional programming interface
 * @export
 */
export const PingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PingApiAxiosParamCreator(configuration);
  return {
    /**
     * Attempts to ping the API
     * @summary Attempts to ping the API
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPing(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPing(
        xApiSecret,
        xRequestedWith,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PingApi - factory interface
 * @export
 */
export const PingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PingApiFp(configuration);
  return {
    /**
     * Attempts to ping the API
     * @summary Attempts to ping the API
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPing(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getPing(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PingApi - object-oriented interface
 * @export
 * @class PingApi
 * @extends {BaseAPI}
 */
export class PingApi extends BaseAPI {
  /**
   * Attempts to ping the API
   * @summary Attempts to ping the API
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PingApi
   */
  public getPing(xApiSecret: string, xRequestedWith: string, options?: any) {
    return PingApiFp(this.configuration)
      .getPing(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PostmarkApi - axios parameter creator
 * @export
 */
export const PostmarkApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Adds an credit to the system
     * @summary Processing webhooks from PostMark
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postmarkWebhook: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("postmarkWebhook", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("postmarkWebhook", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("postmarkWebhook", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/postmark_webhook`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PostmarkApi - functional programming interface
 * @export
 */
export const PostmarkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PostmarkApiAxiosParamCreator(configuration);
  return {
    /**
     * Adds an credit to the system
     * @summary Processing webhooks from PostMark
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postmarkWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postmarkWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PostmarkApi - factory interface
 * @export
 */
export const PostmarkApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PostmarkApiFp(configuration);
  return {
    /**
     * Adds an credit to the system
     * @summary Processing webhooks from PostMark
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postmarkWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Credit> {
      return localVarFp
        .postmarkWebhook(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PostmarkApi - object-oriented interface
 * @export
 * @class PostmarkApi
 * @extends {BaseAPI}
 */
export class PostmarkApi extends BaseAPI {
  /**
   * Adds an credit to the system
   * @summary Processing webhooks from PostMark
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostmarkApi
   */
  public postmarkWebhook(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return PostmarkApiFp(this.configuration)
      .postmarkWebhook(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PreviewApi - axios parameter creator
 * @export
 */
export const PreviewApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a pdf preview.
     * @summary Returns a pdf preview
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPreview: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getPreview", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getPreview", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/preview`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PreviewApi - functional programming interface
 * @export
 */
export const PreviewApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PreviewApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a pdf preview.
     * @summary Returns a pdf preview
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPreview(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPreview(
        xApiSecret,
        xRequestedWith,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PreviewApi - factory interface
 * @export
 */
export const PreviewApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PreviewApiFp(configuration);
  return {
    /**
     * Returns a pdf preview.
     * @summary Returns a pdf preview
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPreview(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getPreview(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PreviewApi - object-oriented interface
 * @export
 * @class PreviewApi
 * @extends {BaseAPI}
 */
export class PreviewApi extends BaseAPI {
  /**
   * Returns a pdf preview.
   * @summary Returns a pdf preview
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PreviewApi
   */
  public getPreview(xApiSecret: string, xRequestedWith: string, options?: any) {
    return PreviewApiFp(this.configuration)
      .getPreview(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of products
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkProducts: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkProducts", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkProducts", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkProducts", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkProducts", "requestBody", requestBody);
      const localVarPath = `/api/v1/products/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an Product by id
     * @summary Deletes a Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProduct: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteProduct", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteProduct", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteProduct", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteProduct", "id", id);
      const localVarPath = `/api/v1/products/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Product by id
     * @summary Shows an Product for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editProduct: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editProduct", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editProduct", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editProduct", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editProduct", "id", id);
      const localVarPath = `/api/v1/products/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists products, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the products, these are handled by the ProductFilters class which defines the methods available
     * @summary Gets a list of products
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProducts: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getProducts", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getProducts", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getProducts", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Product object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getProductsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getProductsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getProductsCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/products/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Product by id
     * @summary Shows an Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showProduct: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showProduct", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showProduct", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showProduct", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showProduct", "id", id);
      const localVarPath = `/api/v1/products/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an Product to the system
     * @summary Adds a Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeProduct: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeProduct", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeProduct", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeProduct", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an Product by id
     * @summary Updates an Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateProduct", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateProduct", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateProduct", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateProduct", "id", id);
      const localVarPath = `/api/v1/products/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a product
     * @summary Uploads a document to a product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadProduct: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadProduct", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadProduct", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadProduct", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadProduct", "id", id);
      const localVarPath = `/api/v1/products/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of products
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkProducts(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkProducts(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an Product by id
     * @summary Deletes a Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Product by id
     * @summary Shows an Product for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists products, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the products, these are handled by the ProductFilters class which defines the methods available
     * @summary Gets a list of products
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProducts(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Product object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProductsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProductsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Product by id
     * @summary Shows an Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an Product to the system
     * @summary Adds a Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an Product by id
     * @summary Updates an Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a product
     * @summary Uploads a document to a product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProductsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of products
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkProducts(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .bulkProducts(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an Product by id
     * @summary Deletes a Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteProduct(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Product by id
     * @summary Shows an Product for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .editProduct(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists products, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the products, these are handled by the ProductFilters class which defines the methods available
     * @summary Gets a list of products
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProducts(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .getProducts(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Product object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .getProductsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Product by id
     * @summary Shows an Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .showProduct(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an Product to the system
     * @summary Adds a Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .storeProduct(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an Product by id
     * @summary Updates an Product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .updateProduct(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a product
     * @summary Uploads a document to a product
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Product Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadProduct(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Product> {
      return localVarFp
        .uploadProduct(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of products
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Hashed IDs
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public bulkProducts(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .bulkProducts(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an Product by id
   * @summary Deletes a Product
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Product Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public deleteProduct(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .deleteProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Product by id
   * @summary Shows an Product for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Product Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public editProduct(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .editProduct(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists products, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the products, these are handled by the ProductFilters class which defines the methods available
   * @summary Gets a list of products
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public getProducts(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .getProducts(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank Product object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public getProductsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .getProductsCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Product by id
   * @summary Shows an Product
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Product Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public showProduct(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .showProduct(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an Product to the system
   * @summary Adds a Product
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public storeProduct(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .storeProduct(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an Product by id
   * @summary Updates an Product
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Product Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public updateProduct(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .updateProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a product
   * @summary Uploads a document to a product
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Product Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductsApi
   */
  public uploadProduct(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProductsApiFp(this.configuration)
      .uploadProduct(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of projects
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkProjects: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkProjects", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkProjects", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkProjects", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkProjects", "requestBody", requestBody);
      const localVarPath = `/api/v1/projects/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a project by id
     * @summary Deletes a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProject: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteProject", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteProject", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteProject", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteProject", "id", id);
      const localVarPath = `/api/v1/projects/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a project by id
     * @summary Shows a project for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editProject: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editProject", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editProject", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editProject", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editProject", "id", id);
      const localVarPath = `/api/v1/projects/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists projects
     * @summary Gets a list of projects
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getProjects", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getProjects", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getProjects", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/projects`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank project object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getProjectsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getProjectsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getProjectsCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/projects/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a project by id
     * @summary Shows a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showProject: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showProject", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showProject", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showProject", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showProject", "id", id);
      const localVarPath = `/api/v1/projects/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an project to a company
     * @summary Adds a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeProject: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeProject", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeProject", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeProject", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/projects`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a project by id
     * @summary Updates a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateProject", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateProject", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateProject", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateProject", "id", id);
      const localVarPath = `/api/v1/projects/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a project
     * @summary Uploads a document to a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadProject: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadProject", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadProject", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadProject", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadProject", "id", id);
      const localVarPath = `/api/v1/projects/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of projects
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkProjects(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkProjects(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a project by id
     * @summary Deletes a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a project by id
     * @summary Shows a project for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists projects
     * @summary Gets a list of projects
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProjects(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank project object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProjectsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProjectsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a project by id
     * @summary Shows a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an project to a company
     * @summary Adds a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a project by id
     * @summary Updates a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a project
     * @summary Uploads a document to a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProjectsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of projects
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkProjects(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .bulkProjects(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a project by id
     * @summary Deletes a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteProject(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a project by id
     * @summary Shows a project for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .editProject(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists projects
     * @summary Gets a list of projects
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .getProjects(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank project object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .getProjectsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a project by id
     * @summary Shows a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .showProject(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an project to a company
     * @summary Adds a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .storeProject(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a project by id
     * @summary Updates a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .updateProject(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a project
     * @summary Uploads a document to a project
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Project Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadProject(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Project> {
      return localVarFp
        .uploadProject(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of projects
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public bulkProjects(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .bulkProjects(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a project by id
   * @summary Deletes a project
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Project Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public deleteProject(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .deleteProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a project by id
   * @summary Shows a project for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Project Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public editProject(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .editProject(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists projects
   * @summary Gets a list of projects
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public getProjects(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .getProjects(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank project object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public getProjectsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .getProjectsCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a project by id
   * @summary Shows a project
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Project Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public showProject(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .showProject(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an project to a company
   * @summary Adds a project
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public storeProject(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .storeProject(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a project by id
   * @summary Updates a project
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Project Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public updateProject(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .updateProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a project
   * @summary Uploads a document to a project
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Project Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public uploadProject(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return ProjectsApiFp(this.configuration)
      .uploadProject(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * QuotesApi - axios parameter creator
 * @export
 */
export const QuotesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Performs a custom action on an Quote.      The current range of actions are as follows     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - convert     - convert_to_invoice     - email
     * @summary Performs a custom action on an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("actionQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("actionQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("actionQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("actionQuote", "id", id);
      // verify required parameter 'action' is not null or undefined
      assertParamExists("actionQuote", "action", action);
      const localVarPath = `/api/v1/quotes/{id}/{action}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"action"}}`, encodeURIComponent(String(action)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Performs bulk actions on an array of quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkQuotes: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkQuotes", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkQuotes", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkQuotes", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkQuotes", "requestBody", requestBody);
      const localVarPath = `/api/v1/quotes/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an Quote by id
     * @summary Deletes a Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteQuote", "id", id);
      const localVarPath = `/api/v1/quotes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Quote by id
     * @summary Shows an Quote for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editQuote", "id", id);
      const localVarPath = `/api/v1/quotes/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists quotes, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the quotes, these are handled by the QuoteFilters class which defines the methods available
     * @summary Gets a list of quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuotes: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getQuotes", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getQuotes", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getQuotes", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/quotes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Quote object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuotesCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getQuotesCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getQuotesCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getQuotesCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/quotes/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an Quote by id
     * @summary Shows an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showQuote", "id", id);
      const localVarPath = `/api/v1/quotes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an Quote to the system
     * @summary Adds a Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeQuote", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/quotes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an Quote by id
     * @summary Updates an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateQuote", "id", id);
      const localVarPath = `/api/v1/quotes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a quote
     * @summary Uploads a document to a quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadQuote", "id", id);
      const localVarPath = `/api/v1/quotes/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QuotesApi - functional programming interface
 * @export
 */
export const QuotesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = QuotesApiAxiosParamCreator(configuration);
  return {
    /**
     * Performs a custom action on an Quote.      The current range of actions are as follows     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - convert     - convert_to_invoice     - email
     * @summary Performs a custom action on an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async actionQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.actionQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Performs bulk actions on an array of quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkQuotes(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an Quote by id
     * @summary Deletes a Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Quote by id
     * @summary Shows an Quote for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists quotes, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the quotes, these are handled by the QuoteFilters class which defines the methods available
     * @summary Gets a list of quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQuotes(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Quote object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQuotesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQuotesCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an Quote by id
     * @summary Shows an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an Quote to the system
     * @summary Adds a Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an Quote by id
     * @summary Updates an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a quote
     * @summary Uploads a document to a quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * QuotesApi - factory interface
 * @export
 */
export const QuotesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = QuotesApiFp(configuration);
  return {
    /**
     * Performs a custom action on an Quote.      The current range of actions are as follows     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - convert     - convert_to_invoice     - email
     * @summary Performs a custom action on an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .actionQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          action,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Performs bulk actions on an array of quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .bulkQuotes(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an Quote by id
     * @summary Deletes a Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Quote by id
     * @summary Shows an Quote for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .editQuote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists quotes, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the quotes, these are handled by the QuoteFilters class which defines the methods available
     * @summary Gets a list of quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .getQuotes(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Quote object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuotesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .getQuotesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an Quote by id
     * @summary Shows an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .showQuote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an Quote to the system
     * @summary Adds a Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .storeQuote(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an Quote by id
     * @summary Updates an Quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .updateQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a quote
     * @summary Uploads a document to a quote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Quote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Quote> {
      return localVarFp
        .uploadQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * QuotesApi - object-oriented interface
 * @export
 * @class QuotesApi
 * @extends {BaseAPI}
 */
export class QuotesApi extends BaseAPI {
  /**
   * Performs a custom action on an Quote.      The current range of actions are as follows     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - convert     - convert_to_invoice     - email
   * @summary Performs a custom action on an Quote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Quote Hashed ID
   * @param {string} action The action string to be performed
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public actionQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    action: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .actionQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Performs bulk actions on an array of quotes
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Hashed ids
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public bulkQuotes(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .bulkQuotes(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an Quote by id
   * @summary Deletes a Quote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Quote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public deleteQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .deleteQuote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Quote by id
   * @summary Shows an Quote for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Quote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public editQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .editQuote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists quotes, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the quotes, these are handled by the QuoteFilters class which defines the methods available
   * @summary Gets a list of quotes
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public getQuotes(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .getQuotes(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank Quote object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public getQuotesCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .getQuotesCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an Quote by id
   * @summary Shows an Quote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Quote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public showQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .showQuote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an Quote to the system
   * @summary Adds a Quote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public storeQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .storeQuote(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an Quote by id
   * @summary Updates an Quote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Quote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public updateQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .updateQuote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a quote
   * @summary Uploads a document to a quote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Quote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QuotesApi
   */
  public uploadQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return QuotesApiFp(this.configuration)
      .uploadQuote(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RecurringInvoicesApi - axios parameter creator
 * @export
 */
export const RecurringInvoicesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Performs a custom action on an RecurringInvoice.      The current range of actions are as follows     - clone_to_RecurringInvoice     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("actionRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("actionRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "actionRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("actionRecurringInvoice", "id", id);
      // verify required parameter 'action' is not null or undefined
      assertParamExists("actionRecurringInvoice", "action", action);
      const localVarPath = `/api/v1/recurring_invoices/{id}/{action}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"action"}}`, encodeURIComponent(String(action)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Performs bulk actions on an array of recurring_invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkRecurringInvoices: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkRecurringInvoices", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkRecurringInvoices", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "bulkRecurringInvoices",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkRecurringInvoices", "requestBody", requestBody);
      const localVarPath = `/api/v1/recurring_invoices/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an RecurringInvoice by id
     * @summary Deletes a RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "deleteRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteRecurringInvoice", "id", id);
      const localVarPath = `/api/v1/recurring_invoices/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an RecurringInvoice by id
     * @summary Shows an RecurringInvoice for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "editRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editRecurringInvoice", "id", id);
      const localVarPath = `/api/v1/recurring_invoices/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists recurring_invoices, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_invoices, these are handled by the RecurringInvoiceFilters class which defines the methods available
     * @summary Gets a list of recurring_invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringInvoices: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getRecurringInvoices", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getRecurringInvoices", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getRecurringInvoices",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/recurring_invoices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank RecurringInvoice object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringInvoicesCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getRecurringInvoicesCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getRecurringInvoicesCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getRecurringInvoicesCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/recurring_invoices/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an RecurringInvoice by id
     * @summary Shows an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "showRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showRecurringInvoice", "id", id);
      const localVarPath = `/api/v1/recurring_invoices/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an RecurringInvoice to the system
     * @summary Adds a RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "storeRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/recurring_invoices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an RecurringInvoice by id
     * @summary Updates an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "updateRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateRecurringInvoice", "id", id);
      const localVarPath = `/api/v1/recurring_invoices/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a recurring_invoice
     * @summary Uploads a document to a recurring_invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadRecurringInvoice: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadRecurringInvoice", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadRecurringInvoice", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "uploadRecurringInvoice",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadRecurringInvoice", "id", id);
      const localVarPath = `/api/v1/recurring_invoices/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecurringInvoicesApi - functional programming interface
 * @export
 */
export const RecurringInvoicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RecurringInvoicesApiAxiosParamCreator(configuration);
  return {
    /**
     * Performs a custom action on an RecurringInvoice.      The current range of actions are as follows     - clone_to_RecurringInvoice     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async actionRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.actionRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          action,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Performs bulk actions on an array of recurring_invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkRecurringInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkRecurringInvoices(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an RecurringInvoice by id
     * @summary Deletes a RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an RecurringInvoice by id
     * @summary Shows an RecurringInvoice for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists recurring_invoices, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_invoices, these are handled by the RecurringInvoiceFilters class which defines the methods available
     * @summary Gets a list of recurring_invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecurringInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecurringInvoices(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank RecurringInvoice object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecurringInvoicesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecurringInvoicesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an RecurringInvoice by id
     * @summary Shows an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an RecurringInvoice to the system
     * @summary Adds a RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.storeRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an RecurringInvoice by id
     * @summary Updates an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a recurring_invoice
     * @summary Uploads a document to a recurring_invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<RecurringInvoice>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uploadRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RecurringInvoicesApi - factory interface
 * @export
 */
export const RecurringInvoicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RecurringInvoicesApiFp(configuration);
  return {
    /**
     * Performs a custom action on an RecurringInvoice.      The current range of actions are as follows     - clone_to_RecurringInvoice     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .actionRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          action,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Performs bulk actions on an array of recurring_invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed IDs
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkRecurringInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .bulkRecurringInvoices(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an RecurringInvoice by id
     * @summary Deletes a RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an RecurringInvoice by id
     * @summary Shows an RecurringInvoice for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .editRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists recurring_invoices, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_invoices, these are handled by the RecurringInvoiceFilters class which defines the methods available
     * @summary Gets a list of recurring_invoices
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringInvoices(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .getRecurringInvoices(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank RecurringInvoice object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringInvoicesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .getRecurringInvoicesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an RecurringInvoice by id
     * @summary Shows an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .showRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an RecurringInvoice to the system
     * @summary Adds a RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .storeRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an RecurringInvoice by id
     * @summary Updates an RecurringInvoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .updateRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a recurring_invoice
     * @summary Uploads a document to a recurring_invoice
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringInvoice Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadRecurringInvoice(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringInvoice> {
      return localVarFp
        .uploadRecurringInvoice(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RecurringInvoicesApi - object-oriented interface
 * @export
 * @class RecurringInvoicesApi
 * @extends {BaseAPI}
 */
export class RecurringInvoicesApi extends BaseAPI {
  /**
   * Performs a custom action on an RecurringInvoice.      The current range of actions are as follows     - clone_to_RecurringInvoice     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
   * @summary Performs a custom action on an RecurringInvoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringInvoice Hashed ID
   * @param {string} action The action string to be performed
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public actionRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    action: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .actionRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Performs bulk actions on an array of recurring_invoices
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Hashed IDs
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public bulkRecurringInvoices(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .bulkRecurringInvoices(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an RecurringInvoice by id
   * @summary Deletes a RecurringInvoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringInvoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public deleteRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .deleteRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an RecurringInvoice by id
   * @summary Shows an RecurringInvoice for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringInvoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public editRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .editRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists recurring_invoices, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_invoices, these are handled by the RecurringInvoiceFilters class which defines the methods available
   * @summary Gets a list of recurring_invoices
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public getRecurringInvoices(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .getRecurringInvoices(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank RecurringInvoice object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public getRecurringInvoicesCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .getRecurringInvoicesCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an RecurringInvoice by id
   * @summary Shows an RecurringInvoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringInvoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public showRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .showRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an RecurringInvoice to the system
   * @summary Adds a RecurringInvoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public storeRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .storeRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an RecurringInvoice by id
   * @summary Updates an RecurringInvoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringInvoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public updateRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .updateRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a recurring_invoice
   * @summary Uploads a document to a recurring_invoice
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringInvoice Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringInvoicesApi
   */
  public uploadRecurringInvoice(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringInvoicesApiFp(this.configuration)
      .uploadRecurringInvoice(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RecurringQuotesApi - axios parameter creator
 * @export
 */
export const RecurringQuotesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Performs a custom action on an RecurringQuote.      The current range of actions are as follows     - clone_to_RecurringQuote     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionRecurringQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("actionRecurringQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("actionRecurringQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "actionRecurringQuote",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("actionRecurringQuote", "id", id);
      // verify required parameter 'action' is not null or undefined
      assertParamExists("actionRecurringQuote", "action", action);
      const localVarPath = `/api/v1/recurring_quotes/{id}/{action}`
        .replace(`{${"id"}}`, encodeURIComponent(String(id)))
        .replace(`{${"action"}}`, encodeURIComponent(String(action)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Performs bulk actions on an array of recurring_quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkRecurringQuotes: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkRecurringQuotes", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkRecurringQuotes", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "bulkRecurringQuotes",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkRecurringQuotes", "requestBody", requestBody);
      const localVarPath = `/api/v1/recurring_quotes/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an RecurringQuote by id
     * @summary Deletes a RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecurringQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteRecurringQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteRecurringQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "deleteRecurringQuote",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteRecurringQuote", "id", id);
      const localVarPath = `/api/v1/recurring_quotes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an RecurringQuote by id
     * @summary Shows an RecurringQuote for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editRecurringQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editRecurringQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editRecurringQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editRecurringQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editRecurringQuote", "id", id);
      const localVarPath = `/api/v1/recurring_quotes/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists recurring_quotes, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_quotes, these are handled by the RecurringQuoteFilters class which defines the methods available
     * @summary Gets a list of recurring_quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringQuotes: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getRecurringQuotes", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getRecurringQuotes", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getRecurringQuotes", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/recurring_quotes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank RecurringQuote object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringQuotesCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getRecurringQuotesCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getRecurringQuotesCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getRecurringQuotesCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/recurring_quotes/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an RecurringQuote by id
     * @summary Shows an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showRecurringQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showRecurringQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showRecurringQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showRecurringQuote", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showRecurringQuote", "id", id);
      const localVarPath = `/api/v1/recurring_quotes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an RecurringQuote to the system
     * @summary Adds a RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeRecurringQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeRecurringQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeRecurringQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "storeRecurringQuote",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/recurring_quotes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an RecurringQuote by id
     * @summary Updates an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecurringQuote: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateRecurringQuote", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateRecurringQuote", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "updateRecurringQuote",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateRecurringQuote", "id", id);
      const localVarPath = `/api/v1/recurring_quotes/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RecurringQuotesApi - functional programming interface
 * @export
 */
export const RecurringQuotesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RecurringQuotesApiAxiosParamCreator(configuration);
  return {
    /**
     * Performs a custom action on an RecurringQuote.      The current range of actions are as follows     - clone_to_RecurringQuote     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async actionRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.actionRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          action,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Performs bulk actions on an array of recurring_quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkRecurringQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkRecurringQuotes(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an RecurringQuote by id
     * @summary Deletes a RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an RecurringQuote by id
     * @summary Shows an RecurringQuote for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists recurring_quotes, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_quotes, these are handled by the RecurringQuoteFilters class which defines the methods available
     * @summary Gets a list of recurring_quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecurringQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecurringQuotes(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank RecurringQuote object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRecurringQuotesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRecurringQuotesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an RecurringQuote by id
     * @summary Shows an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an RecurringQuote to the system
     * @summary Adds a RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.storeRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an RecurringQuote by id
     * @summary Updates an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringQuote>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RecurringQuotesApi - factory interface
 * @export
 */
export const RecurringQuotesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RecurringQuotesApiFp(configuration);
  return {
    /**
     * Performs a custom action on an RecurringQuote.      The current range of actions are as follows     - clone_to_RecurringQuote     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
     * @summary Performs a custom action on an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} action The action string to be performed
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    actionRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      action: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .actionRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          action,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Performs bulk actions on an array of recurring_quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkRecurringQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .bulkRecurringQuotes(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an RecurringQuote by id
     * @summary Deletes a RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an RecurringQuote by id
     * @summary Shows an RecurringQuote for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .editRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists recurring_quotes, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_quotes, these are handled by the RecurringQuoteFilters class which defines the methods available
     * @summary Gets a list of recurring_quotes
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringQuotes(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .getRecurringQuotes(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank RecurringQuote object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecurringQuotesCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .getRecurringQuotesCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an RecurringQuote by id
     * @summary Shows an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .showRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an RecurringQuote to the system
     * @summary Adds a RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .storeRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an RecurringQuote by id
     * @summary Updates an RecurringQuote
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The RecurringQuote Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRecurringQuote(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<RecurringQuote> {
      return localVarFp
        .updateRecurringQuote(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RecurringQuotesApi - object-oriented interface
 * @export
 * @class RecurringQuotesApi
 * @extends {BaseAPI}
 */
export class RecurringQuotesApi extends BaseAPI {
  /**
   * Performs a custom action on an RecurringQuote.      The current range of actions are as follows     - clone_to_RecurringQuote     - clone_to_quote     - history     - delivery_note     - mark_paid     - download     - archive     - delete     - email
   * @summary Performs a custom action on an RecurringQuote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringQuote Hashed ID
   * @param {string} action The action string to be performed
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public actionRecurringQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    action: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .actionRecurringQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        action,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Performs bulk actions on an array of recurring_quotes
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Hashed ids
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public bulkRecurringQuotes(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .bulkRecurringQuotes(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an RecurringQuote by id
   * @summary Deletes a RecurringQuote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringQuote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public deleteRecurringQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .deleteRecurringQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an RecurringQuote by id
   * @summary Shows an RecurringQuote for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringQuote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public editRecurringQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .editRecurringQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists recurring_quotes, search and filters allow fine grained lists to be generated.          Query parameters can be added to performed more fine grained filtering of the recurring_quotes, these are handled by the RecurringQuoteFilters class which defines the methods available
   * @summary Gets a list of recurring_quotes
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public getRecurringQuotes(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .getRecurringQuotes(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank RecurringQuote object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public getRecurringQuotesCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .getRecurringQuotesCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an RecurringQuote by id
   * @summary Shows an RecurringQuote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringQuote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public showRecurringQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .showRecurringQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an RecurringQuote to the system
   * @summary Adds a RecurringQuote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public storeRecurringQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .storeRecurringQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an RecurringQuote by id
   * @summary Updates an RecurringQuote
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The RecurringQuote Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RecurringQuotesApi
   */
  public updateRecurringQuote(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return RecurringQuotesApiFp(this.configuration)
      .updateRecurringQuote(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RefreshApi - axios parameter creator
 * @export
 */
export const RefreshApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Refreshes the dataset
     * @summary Refreshes the dataset
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("refresh", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("refresh", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("refresh", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (includeStatic !== undefined) {
        localVarQueryParameter["include_static"] = includeStatic;
      }

      if (clearCache !== undefined) {
        localVarQueryParameter["clear_cache"] = clearCache;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RefreshApi - functional programming interface
 * @export
 */
export const RefreshApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RefreshApiAxiosParamCreator(configuration);
  return {
    /**
     * Refreshes the dataset
     * @summary Refreshes the dataset
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refresh(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        includeStatic,
        clearCache,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * RefreshApi - factory interface
 * @export
 */
export const RefreshApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = RefreshApiFp(configuration);
  return {
    /**
     * Refreshes the dataset
     * @summary Refreshes the dataset
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [includeStatic] Returns static variables
     * @param {string} [clearCache] Clears the static cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refresh(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      includeStatic?: string,
      clearCache?: string,
      options?: any
    ): AxiosPromise<CompanyUser> {
      return localVarFp
        .refresh(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          includeStatic,
          clearCache,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RefreshApi - object-oriented interface
 * @export
 * @class RefreshApi
 * @extends {BaseAPI}
 */
export class RefreshApi extends BaseAPI {
  /**
   * Refreshes the dataset
   * @summary Refreshes the dataset
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [includeStatic] Returns static variables
   * @param {string} [clearCache] Clears the static cache
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RefreshApi
   */
  public refresh(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    includeStatic?: string,
    clearCache?: string,
    options?: any
  ) {
    return RefreshApiFp(this.configuration)
      .refresh(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        includeStatic,
        clearCache,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SignupApi - axios parameter creator
 * @export
 */
export const SignupApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Attempts a new account signup and returns a CompanyUser object on success
     * @summary Attempts a new account signup
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} tokenName A custom name for the user company token
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSignup: async (
      xApiSecret: string,
      xRequestedWith: string,
      tokenName: string,
      inlineObject: InlineObject,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("postSignup", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("postSignup", "xRequestedWith", xRequestedWith);
      // verify required parameter 'tokenName' is not null or undefined
      assertParamExists("postSignup", "tokenName", tokenName);
      // verify required parameter 'inlineObject' is not null or undefined
      assertParamExists("postSignup", "inlineObject", inlineObject);
      const localVarPath = `/api/v1/signup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tokenName !== undefined) {
        localVarQueryParameter["token_name"] = tokenName;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SignupApi - functional programming interface
 * @export
 */
export const SignupApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SignupApiAxiosParamCreator(configuration);
  return {
    /**
     * Attempts a new account signup and returns a CompanyUser object on success
     * @summary Attempts a new account signup
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} tokenName A custom name for the user company token
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSignup(
      xApiSecret: string,
      xRequestedWith: string,
      tokenName: string,
      inlineObject: InlineObject,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postSignup(
        xApiSecret,
        xRequestedWith,
        tokenName,
        inlineObject,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SignupApi - factory interface
 * @export
 */
export const SignupApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SignupApiFp(configuration);
  return {
    /**
     * Attempts a new account signup and returns a CompanyUser object on success
     * @summary Attempts a new account signup
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} tokenName A custom name for the user company token
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSignup(
      xApiSecret: string,
      xRequestedWith: string,
      tokenName: string,
      inlineObject: InlineObject,
      options?: any
    ): AxiosPromise<CompanyUser> {
      return localVarFp
        .postSignup(
          xApiSecret,
          xRequestedWith,
          tokenName,
          inlineObject,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SignupApi - object-oriented interface
 * @export
 * @class SignupApi
 * @extends {BaseAPI}
 */
export class SignupApi extends BaseAPI {
  /**
   * Attempts a new account signup and returns a CompanyUser object on success
   * @summary Attempts a new account signup
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} tokenName A custom name for the user company token
   * @param {InlineObject} inlineObject
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SignupApi
   */
  public postSignup(
    xApiSecret: string,
    xRequestedWith: string,
    tokenName: string,
    inlineObject: InlineObject,
    options?: any
  ) {
    return SignupApiFp(this.configuration)
      .postSignup(xApiSecret, xRequestedWith, tokenName, inlineObject, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSubscriptions: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkSubscriptions", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkSubscriptions", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkSubscriptions", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkSubscriptions", "requestBody", requestBody);
      const localVarPath = `/api/v1/subscriptions/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an subscriptions by id
     * @summary Deletes a subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteSubscription", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteSubscription", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteSubscription", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteSubscription", "id", id);
      const localVarPath = `/api/v1/subscriptions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an subscriptions by id
     * @summary Shows an subscriptions for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editSubscription: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editSubscription", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editSubscription", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editSubscription", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editSubscription", "id", id);
      const localVarPath = `/api/v1/subscriptions/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists subscriptions.
     * @summary Gets a list of subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getSubscriptions", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getSubscriptions", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getSubscriptions", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank subscriptions object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptionsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getSubscriptionsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getSubscriptionsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getSubscriptionsCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/subscriptions/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an subscriptions by id
     * @summary Shows an subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showSubscription: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showSubscription", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showSubscription", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showSubscription", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showSubscription", "id", id);
      const localVarPath = `/api/v1/subscriptions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an subscriptions to the system
     * @summary Adds a subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeSubscription: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeSubscription", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeSubscription", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeSubscription", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/subscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an subscriptions by id
     * @summary Updates an subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateSubscription", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateSubscription", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateSubscription", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateSubscription", "id", id);
      const localVarPath = `/api/v1/subscriptions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SubscriptionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkSubscriptions(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkSubscriptions(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an subscriptions by id
     * @summary Deletes a subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an subscriptions by id
     * @summary Shows an subscriptions for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.editSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists subscriptions.
     * @summary Gets a list of subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubscriptions(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSubscriptions(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank subscriptions object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubscriptionsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSubscriptionsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an subscriptions by id
     * @summary Shows an subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.showSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an subscriptions to the system
     * @summary Adds a subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.storeSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an subscriptions by id
     * @summary Updates an subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SubscriptionsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSubscriptions(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Subscription> {
      return localVarFp
        .bulkSubscriptions(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an subscriptions by id
     * @summary Deletes a subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an subscriptions by id
     * @summary Shows an subscriptions for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Subscription> {
      return localVarFp
        .editSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists subscriptions.
     * @summary Gets a list of subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Subscription> {
      return localVarFp
        .getSubscriptions(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank subscriptions object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptionsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Subscription> {
      return localVarFp
        .getSubscriptionsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an subscriptions by id
     * @summary Shows an subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Subscription> {
      return localVarFp
        .showSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an subscriptions to the system
     * @summary Adds a subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Subscription> {
      return localVarFp
        .storeSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an subscriptions by id
     * @summary Updates an subscriptions
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Subscription Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Subscription> {
      return localVarFp
        .updateSubscription(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of subscriptions
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public bulkSubscriptions(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .bulkSubscriptions(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an subscriptions by id
   * @summary Deletes a subscriptions
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Subscription Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public deleteSubscription(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .deleteSubscription(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an subscriptions by id
   * @summary Shows an subscriptions for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Subscription Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public editSubscription(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .editSubscription(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists subscriptions.
   * @summary Gets a list of subscriptions
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public getSubscriptions(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .getSubscriptions(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank subscriptions object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public getSubscriptionsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .getSubscriptionsCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an subscriptions by id
   * @summary Shows an subscriptions
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Subscription Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public showSubscription(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .showSubscription(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an subscriptions to the system
   * @summary Adds a subscriptions
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public storeSubscription(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .storeSubscription(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an subscriptions by id
   * @summary Updates an subscriptions
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Subscription Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  public updateSubscription(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return SubscriptionsApiFp(this.configuration)
      .updateSubscription(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SupportApi - axios parameter creator
 * @export
 */
export const SupportApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Allows a user to send a support message to the Invoice Ninja Team
     * @summary Sends a support message to Invoice Ninja team
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} body The message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supportMessage: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      body: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("supportMessage", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("supportMessage", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("supportMessage", "xRequestedWith", xRequestedWith);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("supportMessage", "body", body);
      const localVarPath = `/api/v1/support/messages/send`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SupportApi - functional programming interface
 * @export
 */
export const SupportApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SupportApiAxiosParamCreator(configuration);
  return {
    /**
     * Allows a user to send a support message to the Invoice Ninja Team
     * @summary Sends a support message to Invoice Ninja team
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} body The message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async supportMessage(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      body: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.supportMessage(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SupportApi - factory interface
 * @export
 */
export const SupportApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SupportApiFp(configuration);
  return {
    /**
     * Allows a user to send a support message to the Invoice Ninja Team
     * @summary Sends a support message to Invoice Ninja team
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} body The message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supportMessage(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      body: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .supportMessage(xApiSecret, xApiToken, xRequestedWith, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SupportApi - object-oriented interface
 * @export
 * @class SupportApi
 * @extends {BaseAPI}
 */
export class SupportApi extends BaseAPI {
  /**
   * Allows a user to send a support message to the Invoice Ninja Team
   * @summary Sends a support message to Invoice Ninja team
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} body The message
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public supportMessage(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    body: string,
    options?: any
  ) {
    return SupportApiFp(this.configuration)
      .supportMessage(xApiSecret, xApiToken, xRequestedWith, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SystemLogsApi - axios parameter creator
 * @export
 */
export const SystemLogsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Lists system logs, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the system logs, these are handled by the SystemLogFilters class which defines the methods available
     * @summary Gets a list of system logs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemLogs: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getSystemLogs", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getSystemLogs", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getSystemLogs", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/system_logs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a system_logs by id
     * @summary Shows a system_logs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The system_logs Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showSystemLogs: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showSystemLogs", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showSystemLogs", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showSystemLogs", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showSystemLogs", "id", id);
      const localVarPath = `/api/v1/system_logs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemLogsApi - functional programming interface
 * @export
 */
export const SystemLogsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SystemLogsApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists system logs, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the system logs, these are handled by the SystemLogFilters class which defines the methods available
     * @summary Gets a list of system logs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemLogs(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemLogs(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a system_logs by id
     * @summary Shows a system_logs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The system_logs Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showSystemLogs(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemLog>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showSystemLogs(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SystemLogsApi - factory interface
 * @export
 */
export const SystemLogsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SystemLogsApiFp(configuration);
  return {
    /**
     * Lists system logs, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the system logs, these are handled by the SystemLogFilters class which defines the methods available
     * @summary Gets a list of system logs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemLogs(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<SystemLog> {
      return localVarFp
        .getSystemLogs(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a system_logs by id
     * @summary Shows a system_logs
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The system_logs Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showSystemLogs(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<SystemLog> {
      return localVarFp
        .showSystemLogs(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SystemLogsApi - object-oriented interface
 * @export
 * @class SystemLogsApi
 * @extends {BaseAPI}
 */
export class SystemLogsApi extends BaseAPI {
  /**
   * Lists system logs, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the system logs, these are handled by the SystemLogFilters class which defines the methods available
   * @summary Gets a list of system logs
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemLogsApi
   */
  public getSystemLogs(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return SystemLogsApiFp(this.configuration)
      .getSystemLogs(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a system_logs by id
   * @summary Shows a system_logs
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The system_logs Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemLogsApi
   */
  public showSystemLogs(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return SystemLogsApiFp(this.configuration)
      .showSystemLogs(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TaskStatusApi - axios parameter creator
 * @export
 */
export const TaskStatusApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of task statuses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody TaskStatus Ter,s
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTaskStatuss: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkTaskStatuss", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkTaskStatuss", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkTaskStatuss", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkTaskStatuss", "requestBody", requestBody);
      const localVarPath = `/api/v1/task_statuses/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an TaskStatusby id
     * @summary Shows an TaskStatusfor editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTaskStatuss: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editTaskStatuss", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editTaskStatuss", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editTaskStatuss", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editTaskStatuss", "id", id);
      const localVarPath = `/api/v1/task_statuses/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists task statuses
     * @summary Gets a list of task statuses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStatuses: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getTaskStatuses", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getTaskStatuses", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getTaskStatuses", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/task_statuses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank TaskStatus object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStatussCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getTaskStatussCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getTaskStatussCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "getTaskStatussCreate",
        "xRequestedWith",
        xRequestedWith
      );
      const localVarPath = `/api/v1/task_statuses/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an TaskStatusby id
     * @summary Shows a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTaskStatus: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showTaskStatus", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showTaskStatus", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showTaskStatus", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showTaskStatus", "id", id);
      const localVarPath = `/api/v1/task_statuses/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds a TaskStatusto the system
     * @summary Adds a TaskStatus
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {TaskStatus} taskStatus The task_status request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeTaskStatus: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      taskStatus: TaskStatus,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeTaskStatus", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeTaskStatus", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeTaskStatus", "xRequestedWith", xRequestedWith);
      // verify required parameter 'taskStatus' is not null or undefined
      assertParamExists("storeTaskStatus", "taskStatus", taskStatus);
      const localVarPath = `/api/v1/task_statuses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        taskStatus,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an TaskStatus Termby id
     * @summary Updates a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaskStatus: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateTaskStatus", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateTaskStatus", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateTaskStatus", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateTaskStatus", "id", id);
      const localVarPath = `/api/v1/task_statuses/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TaskStatusApi - functional programming interface
 * @export
 */
export const TaskStatusApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TaskStatusApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of task statuses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody TaskStatus Ter,s
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkTaskStatuss(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkTaskStatuss(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an TaskStatusby id
     * @summary Shows an TaskStatusfor editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editTaskStatuss(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editTaskStatuss(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists task statuses
     * @summary Gets a list of task statuses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskStatuses(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskStatuses(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank TaskStatus object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskStatussCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTaskStatussCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an TaskStatusby id
     * @summary Shows a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showTaskStatus(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds a TaskStatusto the system
     * @summary Adds a TaskStatus
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {TaskStatus} taskStatus The task_status request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      taskStatus: TaskStatus,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeTaskStatus(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        taskStatus,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an TaskStatus Termby id
     * @summary Updates a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateTaskStatus(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TaskStatusApi - factory interface
 * @export
 */
export const TaskStatusApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TaskStatusApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of task statuses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody TaskStatus Ter,s
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTaskStatuss(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<TaskStatus> {
      return localVarFp
        .bulkTaskStatuss(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an TaskStatusby id
     * @summary Shows an TaskStatusfor editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTaskStatuss(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<TaskStatus> {
      return localVarFp
        .editTaskStatuss(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists task statuses
     * @summary Gets a list of task statuses
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStatuses(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<TaskStatus> {
      return localVarFp
        .getTaskStatuses(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank TaskStatus object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskStatussCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<TaskStatus> {
      return localVarFp
        .getTaskStatussCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an TaskStatusby id
     * @summary Shows a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<TaskStatus> {
      return localVarFp
        .showTaskStatus(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a TaskStatusto the system
     * @summary Adds a TaskStatus
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {TaskStatus} taskStatus The task_status request
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      taskStatus: TaskStatus,
      include?: string,
      options?: any
    ): AxiosPromise<TaskStatus> {
      return localVarFp
        .storeTaskStatus(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          taskStatus,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an TaskStatus Termby id
     * @summary Updates a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<TaskStatus> {
      return localVarFp
        .updateTaskStatus(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TaskStatusApi - object-oriented interface
 * @export
 * @class TaskStatusApi
 * @extends {BaseAPI}
 */
export class TaskStatusApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of task statuses
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody TaskStatus Ter,s
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatusApi
   */
  public bulkTaskStatuss(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return TaskStatusApiFp(this.configuration)
      .bulkTaskStatuss(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an TaskStatusby id
   * @summary Shows an TaskStatusfor editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaskStatusHashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatusApi
   */
  public editTaskStatuss(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TaskStatusApiFp(this.configuration)
      .editTaskStatuss(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists task statuses
   * @summary Gets a list of task statuses
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatusApi
   */
  public getTaskStatuses(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return TaskStatusApiFp(this.configuration)
      .getTaskStatuses(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank TaskStatus object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatusApi
   */
  public getTaskStatussCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return TaskStatusApiFp(this.configuration)
      .getTaskStatussCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an TaskStatusby id
   * @summary Shows a TaskStatus Term
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaskStatusHashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatusApi
   */
  public showTaskStatus(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TaskStatusApiFp(this.configuration)
      .showTaskStatus(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a TaskStatusto the system
   * @summary Adds a TaskStatus
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {TaskStatus} taskStatus The task_status request
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatusApi
   */
  public storeTaskStatus(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    taskStatus: TaskStatus,
    include?: string,
    options?: any
  ) {
    return TaskStatusApiFp(this.configuration)
      .storeTaskStatus(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        taskStatus,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an TaskStatus Termby id
   * @summary Updates a TaskStatus Term
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaskStatusHashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatusApi
   */
  public updateTaskStatus(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TaskStatusApiFp(this.configuration)
      .updateTaskStatus(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TaskStatussApi - axios parameter creator
 * @export
 */
export const TaskStatussApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Handles the deletion of an TaskStatus by id
     * @summary Deletes a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskStatus: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteTaskStatus", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteTaskStatus", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteTaskStatus", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteTaskStatus", "id", id);
      const localVarPath = `/api/v1/task_statuses/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TaskStatussApi - functional programming interface
 * @export
 */
export const TaskStatussApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TaskStatussApiAxiosParamCreator(configuration);
  return {
    /**
     * Handles the deletion of an TaskStatus by id
     * @summary Deletes a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteTaskStatus(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TaskStatussApi - factory interface
 * @export
 */
export const TaskStatussApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TaskStatussApiFp(configuration);
  return {
    /**
     * Handles the deletion of an TaskStatus by id
     * @summary Deletes a TaskStatus Term
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaskStatusHashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaskStatus(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteTaskStatus(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TaskStatussApi - object-oriented interface
 * @export
 * @class TaskStatussApi
 * @extends {BaseAPI}
 */
export class TaskStatussApi extends BaseAPI {
  /**
   * Handles the deletion of an TaskStatus by id
   * @summary Deletes a TaskStatus Term
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaskStatusHashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaskStatussApi
   */
  public deleteTaskStatus(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TaskStatussApiFp(this.configuration)
      .deleteTaskStatus(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of tasks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTasks: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkTasks", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkTasks", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkTasks", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkTasks", "requestBody", requestBody);
      const localVarPath = `/api/v1/tasks/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTask: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteTask", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteTask", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteTask", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteTask", "id", id);
      const localVarPath = `/api/v1/tasks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTask: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editTask", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editTask", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editTask", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editTask", "id", id);
      const localVarPath = `/api/v1/tasks/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists tasks, search and filters allow fine grained lists to be generated.      *      *   Query parameters can be added to performed more fine grained filtering of the tasks, these are handled by the TaskFilters class which defines the methods available
     * @summary Gets a list of tasks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getTasks", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getTasks", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getTasks", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasksCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getTasksCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getTasksCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getTasksCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tasks/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTask: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showTask", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showTask", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showTask", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showTask", "id", id);
      const localVarPath = `/api/v1/tasks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sorts tasks after drag and drop on the KanBan.
     * @summary Sort tasks on KanBan
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sortTasks: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("sortTasks", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("sortTasks", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("sortTasks", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tasks/stort`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeTask: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeTask", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeTask", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeTask", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tasks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTask: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateTask", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateTask", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateTask", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateTask", "id", id);
      const localVarPath = `/api/v1/tasks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a task
     * @summary Uploads a document to a task
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadTask: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadTask", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadTask", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadTask", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadTask", "id", id);
      const localVarPath = `/api/v1/tasks/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of tasks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkTasks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkTasks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editTask(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists tasks, search and filters allow fine grained lists to be generated.      *      *   Query parameters can be added to performed more fine grained filtering of the tasks, these are handled by the TaskFilters class which defines the methods available
     * @summary Gets a list of tasks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTasks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTasksCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTasksCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showTask(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Sorts tasks after drag and drop on the KanBan.
     * @summary Sort tasks on KanBan
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sortTasks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sortTasks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeTask(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a task
     * @summary Uploads a document to a task
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTask(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TasksApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of tasks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTasks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .bulkTasks(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .editTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists tasks, search and filters allow fine grained lists to be generated.      *      *   Query parameters can be added to performed more fine grained filtering of the tasks, these are handled by the TaskFilters class which defines the methods available
     * @summary Gets a list of tasks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .getTasks(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasksCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .getTasksCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .showTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sorts tasks after drag and drop on the KanBan.
     * @summary Sort tasks on KanBan
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sortTasks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .sortTasks(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .storeTask(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .updateTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a task
     * @summary Uploads a document to a task
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Task Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadTask(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Task> {
      return localVarFp
        .uploadTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of tasks
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public bulkTasks(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .bulkTasks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a client by id
   * @summary Deletes a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Task Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public deleteTask(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .deleteTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Task Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public editTask(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .editTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists tasks, search and filters allow fine grained lists to be generated.      *      *   Query parameters can be added to performed more fine grained filtering of the tasks, these are handled by the TaskFilters class which defines the methods available
   * @summary Gets a list of tasks
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTasks(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .getTasks(xApiSecret, xApiToken, xRequestedWith, include, index, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank client object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTasksCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .getTasksCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Task Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public showTask(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .showTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sorts tasks after drag and drop on the KanBan.
   * @summary Sort tasks on KanBan
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public sortTasks(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .sortTasks(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an client to a company
   * @summary Adds a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public storeTask(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .storeTask(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a client by id
   * @summary Updates a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Task Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public updateTask(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .updateTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a task
   * @summary Uploads a document to a task
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Task Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public uploadTask(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TasksApiFp(this.configuration)
      .uploadTask(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TaxRatesApi - axios parameter creator
 * @export
 */
export const TaxRatesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of TaxRates
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Tax Rates
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTaxRates: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkTaxRates", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkTaxRates", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkTaxRates", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkTaxRates", "requestBody", requestBody);
      const localVarPath = `/api/v1/tax_rates/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an TaxRate by id
     * @summary Deletes a TaxRate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaxRate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteTaxRate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteTaxRate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteTaxRate", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteTaxRate", "id", id);
      const localVarPath = `/api/v1/tax_rates/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a Tax Rate by id
     * @summary Shows a Tax Rate for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTaxRate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editTaxRate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editTaxRate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editTaxRate", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editTaxRate", "id", id);
      const localVarPath = `/api/v1/tax_rates/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Tax Rate object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaxRateCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getTaxRateCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getTaxRateCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getTaxRateCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tax_rates/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists tax rates
     * @summary Gets a list of tax_rates
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaxRates: async (
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/tax_rates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an TaxRate by id
     * @summary Shows a Tax Rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTaxRate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showTaxRate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showTaxRate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showTaxRate", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showTaxRate", "id", id);
      const localVarPath = `/api/v1/tax_rates/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a tax rate by id
     * @summary Updates a tax rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaxRate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateTaxRate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateTaxRate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateTaxRate", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateTaxRate", "id", id);
      const localVarPath = `/api/v1/tax_rates/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TaxRatesApi - functional programming interface
 * @export
 */
export const TaxRatesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TaxRatesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of TaxRates
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Tax Rates
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkTaxRates(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkTaxRates(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an TaxRate by id
     * @summary Deletes a TaxRate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaxRate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a Tax Rate by id
     * @summary Shows a Tax Rate for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRate>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editTaxRate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Tax Rate object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaxRateCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRate>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTaxRateCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists tax rates
     * @summary Gets a list of tax_rates
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaxRates(
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRate>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTaxRates(
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an TaxRate by id
     * @summary Shows a Tax Rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRate>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showTaxRate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a tax rate by id
     * @summary Updates a tax rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRate>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaxRate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TaxRatesApi - factory interface
 * @export
 */
export const TaxRatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TaxRatesApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of TaxRates
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Tax Rates
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTaxRates(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .bulkTaxRates(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an TaxRate by id
     * @summary Deletes a TaxRate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a Tax Rate by id
     * @summary Shows a Tax Rate for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<TaxRate> {
      return localVarFp
        .editTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Tax Rate object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaxRateCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<TaxRate> {
      return localVarFp
        .getTaxRateCreate(xApiSecret, xApiToken, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists tax rates
     * @summary Gets a list of tax_rates
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaxRates(index?: string, options?: any): AxiosPromise<TaxRate> {
      return localVarFp
        .getTaxRates(index, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an TaxRate by id
     * @summary Shows a Tax Rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<TaxRate> {
      return localVarFp
        .showTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a tax rate by id
     * @summary Updates a tax rate
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The TaxRate Hashed ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTaxRate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      options?: any
    ): AxiosPromise<TaxRate> {
      return localVarFp
        .updateTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TaxRatesApi - object-oriented interface
 * @export
 * @class TaxRatesApi
 * @extends {BaseAPI}
 */
export class TaxRatesApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of TaxRates
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Tax Rates
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxRatesApi
   */
  public bulkTaxRates(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return TaxRatesApiFp(this.configuration)
      .bulkTaxRates(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an TaxRate by id
   * @summary Deletes a TaxRate
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaxRate Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxRatesApi
   */
  public deleteTaxRate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return TaxRatesApiFp(this.configuration)
      .deleteTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a Tax Rate by id
   * @summary Shows a Tax Rate for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaxRate Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxRatesApi
   */
  public editTaxRate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return TaxRatesApiFp(this.configuration)
      .editTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank Tax Rate object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxRatesApi
   */
  public getTaxRateCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    options?: any
  ) {
    return TaxRatesApiFp(this.configuration)
      .getTaxRateCreate(xApiSecret, xApiToken, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists tax rates
   * @summary Gets a list of tax_rates
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxRatesApi
   */
  public getTaxRates(index?: string, options?: any) {
    return TaxRatesApiFp(this.configuration)
      .getTaxRates(index, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an TaxRate by id
   * @summary Shows a Tax Rate
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaxRate Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxRatesApi
   */
  public showTaxRate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return TaxRatesApiFp(this.configuration)
      .showTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a tax rate by id
   * @summary Updates a tax rate
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The TaxRate Hashed ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxRatesApi
   */
  public updateTaxRate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    options?: any
  ) {
    return TaxRatesApiFp(this.configuration)
      .updateTaxRate(xApiSecret, xApiToken, xRequestedWith, id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a entity template with the template variables replaced with the Entities
     * @summary Returns a entity template with the template variables replaced with the Entities
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShowTemplate: async (
      xApiSecret: string,
      xRequestedWith: string,
      inlineObject4: InlineObject4,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getShowTemplate", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getShowTemplate", "xRequestedWith", xRequestedWith);
      // verify required parameter 'inlineObject4' is not null or undefined
      assertParamExists("getShowTemplate", "inlineObject4", inlineObject4);
      const localVarPath = `/api/v1/templates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject4,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TemplatesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a entity template with the template variables replaced with the Entities
     * @summary Returns a entity template with the template variables replaced with the Entities
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShowTemplate(
      xApiSecret: string,
      xRequestedWith: string,
      inlineObject4: InlineObject4,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShowTemplate(
        xApiSecret,
        xRequestedWith,
        inlineObject4,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TemplatesApiFp(configuration);
  return {
    /**
     * Returns a entity template with the template variables replaced with the Entities
     * @summary Returns a entity template with the template variables replaced with the Entities
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {InlineObject4} inlineObject4
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShowTemplate(
      xApiSecret: string,
      xRequestedWith: string,
      inlineObject4: InlineObject4,
      options?: any
    ): AxiosPromise<Template> {
      return localVarFp
        .getShowTemplate(xApiSecret, xRequestedWith, inlineObject4, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
  /**
   * Returns a entity template with the template variables replaced with the Entities
   * @summary Returns a entity template with the template variables replaced with the Entities
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {InlineObject4} inlineObject4
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TemplatesApi
   */
  public getShowTemplate(
    xApiSecret: string,
    xRequestedWith: string,
    inlineObject4: InlineObject4,
    options?: any
  ) {
    return TemplatesApiFp(this.configuration)
      .getShowTemplate(xApiSecret, xRequestedWith, inlineObject4, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Token ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTokens: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkTokens", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkTokens", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkTokens", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkTokens", "requestBody", requestBody);
      const localVarPath = `/api/v1/tokens/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a token by id
     * @summary Deletes a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteToken", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteToken", "id", id);
      const localVarPath = `/api/v1/tokens/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a token by id
     * @summary Shows a token for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editToken", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editToken", "id", id);
      const localVarPath = `/api/v1/tokens/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists company tokens.      *      *   Query parameters can be added to performed more fine grained filtering of the tokens, these are handled by the TokenFilters class which defines the methods available
     * @summary Gets a list of company tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokens: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getTokens", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getTokens", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getTokens", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank token object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokensCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getTokensCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getTokensCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getTokensCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tokens/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a token by id
     * @summary Shows a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showToken", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showToken", "id", id);
      const localVarPath = `/api/v1/tokens/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an token to a company
     * @summary Adds a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeToken", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/tokens`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a token by id
     * @summary Updates a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateToken: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateToken", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateToken", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateToken", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateToken", "id", id);
      const localVarPath = `/api/v1/tokens/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Token ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkTokens(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyToken>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkTokens(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a token by id
     * @summary Deletes a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a token by id
     * @summary Shows a token for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyToken>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists company tokens.      *      *   Query parameters can be added to performed more fine grained filtering of the tokens, these are handled by the TokenFilters class which defines the methods available
     * @summary Gets a list of company tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTokens(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyToken>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank token object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTokensCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyToken>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTokensCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a token by id
     * @summary Shows a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyToken>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an token to a company
     * @summary Adds a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyToken>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a token by id
     * @summary Updates a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyToken>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateToken(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TokensApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Token ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkTokens(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<CompanyToken> {
      return localVarFp
        .bulkTokens(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a token by id
     * @summary Deletes a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a token by id
     * @summary Shows a token for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyToken> {
      return localVarFp
        .editToken(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists company tokens.      *      *   Query parameters can be added to performed more fine grained filtering of the tokens, these are handled by the TokenFilters class which defines the methods available
     * @summary Gets a list of company tokens
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokens(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<CompanyToken> {
      return localVarFp
        .getTokens(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank token object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTokensCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyToken> {
      return localVarFp
        .getTokensCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a token by id
     * @summary Shows a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyToken> {
      return localVarFp
        .showToken(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an token to a company
     * @summary Adds a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyToken> {
      return localVarFp
        .storeToken(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a token by id
     * @summary Updates a token
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Token Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateToken(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<CompanyToken> {
      return localVarFp
        .updateToken(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of tokens
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Token ids
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public bulkTokens(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .bulkTokens(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a token by id
   * @summary Deletes a token
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Token Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public deleteToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .deleteToken(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a token by id
   * @summary Shows a token for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Token Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public editToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .editToken(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists company tokens.      *      *   Query parameters can be added to performed more fine grained filtering of the tokens, these are handled by the TokenFilters class which defines the methods available
   * @summary Gets a list of company tokens
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public getTokens(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .getTokens(xApiSecret, xApiToken, xRequestedWith, include, index, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank token object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public getTokensCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .getTokensCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a token by id
   * @summary Shows a token
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Token Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public showToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .showToken(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an token to a company
   * @summary Adds a token
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public storeToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .storeToken(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a token by id
   * @summary Updates a token
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Token Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public updateToken(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return TokensApiFp(this.configuration)
      .updateToken(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UpdateApi - axios parameter creator
 * @export
 */
export const UpdateApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Performs a system update
     * @summary Performs a system update
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xApiPassword The login password when challenged
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selfUpdate: async (
      xApiSecret: string,
      xApiToken: string,
      xApiPassword: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("selfUpdate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("selfUpdate", "xApiToken", xApiToken);
      // verify required parameter 'xApiPassword' is not null or undefined
      assertParamExists("selfUpdate", "xApiPassword", xApiPassword);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("selfUpdate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/self-update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xApiPassword !== undefined && xApiPassword !== null) {
        localVarHeaderParameter["X-Api-Password"] = String(xApiPassword);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UpdateApi - functional programming interface
 * @export
 */
export const UpdateApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UpdateApiAxiosParamCreator(configuration);
  return {
    /**
     * Performs a system update
     * @summary Performs a system update
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xApiPassword The login password when challenged
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async selfUpdate(
      xApiSecret: string,
      xApiToken: string,
      xApiPassword: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.selfUpdate(
        xApiSecret,
        xApiToken,
        xApiPassword,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UpdateApi - factory interface
 * @export
 */
export const UpdateApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UpdateApiFp(configuration);
  return {
    /**
     * Performs a system update
     * @summary Performs a system update
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xApiPassword The login password when challenged
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selfUpdate(
      xApiSecret: string,
      xApiToken: string,
      xApiPassword: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .selfUpdate(
          xApiSecret,
          xApiToken,
          xApiPassword,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UpdateApi - object-oriented interface
 * @export
 * @class UpdateApi
 * @extends {BaseAPI}
 */
export class UpdateApi extends BaseAPI {
  /**
   * Performs a system update
   * @summary Performs a system update
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xApiPassword The login password when challenged
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpdateApi
   */
  public selfUpdate(
    xApiSecret: string,
    xApiToken: string,
    xApiPassword: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return UpdateApiFp(this.configuration)
      .selfUpdate(
        xApiSecret,
        xApiToken,
        xApiPassword,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of users
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUsers: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkUsers", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkUsers", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkUsers", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkUsers", "requestBody", requestBody);
      const localVarPath = `/api/v1/users/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of an User by id
     * @summary Deletes a User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [tokenName] Customized name for the Users API Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      tokenName?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteUser", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteUser", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteUser", "id", id);
      const localVarPath = `/api/v1/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (tokenName !== undefined) {
        localVarQueryParameter["token_name"] = tokenName;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Detach an existing user from a company
     * @summary Detach an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachUser: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("detachUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("detachUser", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("detachUser", "xRequestedWith", xRequestedWith);
      // verify required parameter 'user' is not null or undefined
      assertParamExists("detachUser", "user", user);
      const localVarPath = `/api/v1/users/{user}/detach_from_company`.replace(
        `{${"user"}}`,
        encodeURIComponent(String(user))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an User by id
     * @summary Shows an User for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUser: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editUser", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editUser", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editUser", "id", id);
      const localVarPath = `/api/v1/users/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists users, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the users, these are handled by the UserFilters class which defines the methods available
     * @summary Gets a list of users
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getUsers", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getUsers", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getUsers", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank User object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getUsersCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getUsersCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getUsersCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/users/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reconfirm an existing user from a company
     * @summary Reconfirm an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("inviteUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("inviteUser", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("inviteUser", "xRequestedWith", xRequestedWith);
      // verify required parameter 'user' is not null or undefined
      assertParamExists("inviteUser", "user", user);
      const localVarPath = `/api/v1/users/{user}/invite`.replace(
        `{${"user"}}`,
        encodeURIComponent(String(user))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reconfirm an existing user from a company
     * @summary Reconfirm an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUserReconfirm: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("inviteUserReconfirm", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("inviteUserReconfirm", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists(
        "inviteUserReconfirm",
        "xRequestedWith",
        xRequestedWith
      );
      // verify required parameter 'user' is not null or undefined
      assertParamExists("inviteUserReconfirm", "user", user);
      const localVarPath = `/api/v1/users/{user}/reconfirm`.replace(
        `{${"user"}}`,
        encodeURIComponent(String(user))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays an User by id
     * @summary Shows an User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showUser: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showUser", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showUser", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showUser", "id", id);
      const localVarPath = `/api/v1/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an User to the system
     * @summary Adds a User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeUser: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeUser", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeUser", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of an User by id
     * @summary Updates an User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateUser", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateUser", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateUser", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateUser", "id", id);
      const localVarPath = `/api/v1/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of users
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUsers(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUsers(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of an User by id
     * @summary Deletes a User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [tokenName] Customized name for the Users API Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      tokenName?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        tokenName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Detach an existing user from a company
     * @summary Detach an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async detachUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.detachUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        user,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an User by id
     * @summary Shows an User for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists users, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the users, these are handled by the UserFilters class which defines the methods available
     * @summary Gets a list of users
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank User object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Reconfirm an existing user from a company
     * @summary Reconfirm an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async inviteUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        user,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Reconfirm an existing user from a company
     * @summary Reconfirm an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async inviteUserReconfirm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.inviteUserReconfirm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          user,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays an User by id
     * @summary Shows an User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an User to the system
     * @summary Adds a User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of an User by id
     * @summary Updates an User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of users
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody Hashed ids
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUsers(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .bulkUsers(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of an User by id
     * @summary Deletes a User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [tokenName] Customized name for the Users API Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      tokenName?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUser(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          tokenName,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Detach an existing user from a company
     * @summary Detach an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .detachUser(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          user,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an User by id
     * @summary Shows an User for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .editUser(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists users, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the users, these are handled by the UserFilters class which defines the methods available
     * @summary Gets a list of users
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .getUsers(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank User object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .getUsersCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Reconfirm an existing user from a company
     * @summary Reconfirm an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .inviteUser(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          user,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Reconfirm an existing user from a company
     * @summary Reconfirm an existing user to a company
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} user The user hashed_id
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUserReconfirm(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      user: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .inviteUserReconfirm(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          user,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays an User by id
     * @summary Shows an User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .showUser(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an User to the system
     * @summary Adds a User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .storeUser(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of an User by id
     * @summary Updates an User
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The User Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .updateUser(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of users
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody Hashed ids
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public bulkUsers(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .bulkUsers(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of an User by id
   * @summary Deletes a User
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The User Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [tokenName] Customized name for the Users API Token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    tokenName?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .deleteUser(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        tokenName,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Detach an existing user from a company
   * @summary Detach an existing user to a company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} user The user hashed_id
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public detachUser(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    user: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .detachUser(xApiSecret, xApiToken, xRequestedWith, user, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an User by id
   * @summary Shows an User for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The User Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public editUser(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .editUser(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists users, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the users, these are handled by the UserFilters class which defines the methods available
   * @summary Gets a list of users
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .getUsers(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank User object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsersCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .getUsersCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Reconfirm an existing user from a company
   * @summary Reconfirm an existing user to a company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} user The user hashed_id
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public inviteUser(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    user: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .inviteUser(xApiSecret, xApiToken, xRequestedWith, user, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Reconfirm an existing user from a company
   * @summary Reconfirm an existing user to a company
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} user The user hashed_id
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public inviteUserReconfirm(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    user: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .inviteUserReconfirm(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        user,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays an User by id
   * @summary Shows an User
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The User Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public showUser(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .showUser(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an User to the system
   * @summary Adds a User
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public storeUser(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .storeUser(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of an User by id
   * @summary Updates an User
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The User Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .updateUser(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VendorsApi - axios parameter creator
 * @export
 */
export const VendorsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of vendors
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkVendors: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkVendors", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkVendors", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkVendors", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkVendors", "requestBody", requestBody);
      const localVarPath = `/api/v1/vendors/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVendor: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteVendor", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteVendor", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteVendor", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteVendor", "id", id);
      const localVarPath = `/api/v1/vendors/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editVendor: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editVendor", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editVendor", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editVendor", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editVendor", "id", id);
      const localVarPath = `/api/v1/vendors/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists vendors, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the vendors, these are handled by the VendorFilters class which defines the methods available
     * @summary Gets a list of vendors
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendors: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getVendors", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getVendors", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getVendors", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/vendors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendorsCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getVendorsCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getVendorsCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getVendorsCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/vendors/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showVendor: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showVendor", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showVendor", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showVendor", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showVendor", "id", id);
      const localVarPath = `/api/v1/vendors/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeVendor: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeVendor", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeVendor", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeVendor", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/vendors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVendor: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateVendor", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateVendor", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateVendor", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateVendor", "id", id);
      const localVarPath = `/api/v1/vendors/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the uploading of a document to a vendor
     * @summary Uploads a document to a vendor
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadVendor: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("uploadVendor", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("uploadVendor", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("uploadVendor", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("uploadVendor", "id", id);
      const localVarPath = `/api/v1/vendors/{id}/upload`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VendorsApi - functional programming interface
 * @export
 */
export const VendorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VendorsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of vendors
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkVendors(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkVendors(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVendor(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editVendor(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists vendors, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the vendors, these are handled by the VendorFilters class which defines the methods available
     * @summary Gets a list of vendors
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVendors(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVendors(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVendorsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getVendorsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showVendor(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeVendor(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateVendor(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the uploading of a document to a vendor
     * @summary Uploads a document to a vendor
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vendor>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadVendor(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * VendorsApi - factory interface
 * @export
 */
export const VendorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VendorsApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of vendors
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkVendors(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .bulkVendors(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a client by id
     * @summary Deletes a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteVendor(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .editVendor(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists vendors, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the vendors, these are handled by the VendorFilters class which defines the methods available
     * @summary Gets a list of vendors
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendors(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .getVendors(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank client object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendorsCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .getVendorsCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a client by id
     * @summary Shows a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .showVendor(xApiSecret, xApiToken, xRequestedWith, id, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an client to a company
     * @summary Adds a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .storeVendor(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a client by id
     * @summary Updates a client
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .updateVendor(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the uploading of a document to a vendor
     * @summary Uploads a document to a vendor
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Vendor Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadVendor(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Vendor> {
      return localVarFp
        .uploadVendor(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VendorsApi - object-oriented interface
 * @export
 * @class VendorsApi
 * @extends {BaseAPI}
 */
export class VendorsApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of vendors
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public bulkVendors(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .bulkVendors(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a client by id
   * @summary Deletes a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Vendor Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public deleteVendor(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .deleteVendor(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Vendor Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public editVendor(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .editVendor(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists vendors, search and filters allow fine grained lists to be generated.      Query parameters can be added to performed more fine grained filtering of the vendors, these are handled by the VendorFilters class which defines the methods available
   * @summary Gets a list of vendors
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public getVendors(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .getVendors(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank client object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public getVendorsCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .getVendorsCreate(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a client by id
   * @summary Shows a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Vendor Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public showVendor(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .showVendor(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an client to a company
   * @summary Adds a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public storeVendor(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .storeVendor(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a client by id
   * @summary Updates a client
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Vendor Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public updateVendor(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .updateVendor(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the uploading of a document to a vendor
   * @summary Uploads a document to a vendor
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Vendor Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VendorsApi
   */
  public uploadVendor(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return VendorsApiFp(this.configuration)
      .uploadVendor(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebcronApi - axios parameter creator
 * @export
 */
export const WebcronApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Executes the task scheduler via a webcron service
     * @summary Executes the task scheduler via a webcron service
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webcron: async (
      xApiSecret: string,
      xRequestedWith: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("webcron", "xApiSecret", xApiSecret);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("webcron", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/webcron`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebcronApi - functional programming interface
 * @export
 */
export const WebcronApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WebcronApiAxiosParamCreator(configuration);
  return {
    /**
     * Executes the task scheduler via a webcron service
     * @summary Executes the task scheduler via a webcron service
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webcron(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webcron(
        xApiSecret,
        xRequestedWith,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebcronApi - factory interface
 * @export
 */
export const WebcronApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebcronApiFp(configuration);
  return {
    /**
     * Executes the task scheduler via a webcron service
     * @summary Executes the task scheduler via a webcron service
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webcron(
      xApiSecret: string,
      xRequestedWith: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .webcron(xApiSecret, xRequestedWith, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WebcronApi - object-oriented interface
 * @export
 * @class WebcronApi
 * @extends {BaseAPI}
 */
export class WebcronApi extends BaseAPI {
  /**
   * Executes the task scheduler via a webcron service
   * @summary Executes the task scheduler via a webcron service
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebcronApi
   */
  public webcron(xApiSecret: string, xRequestedWith: string, options?: any) {
    return WebcronApiFp(this.configuration)
      .webcron(xApiSecret, xRequestedWith, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Performs bulk actions on an array of Webhooks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkWebhooks: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("bulkWebhooks", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("bulkWebhooks", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("bulkWebhooks", "xRequestedWith", xRequestedWith);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("bulkWebhooks", "requestBody", requestBody);
      const localVarPath = `/api/v1/webhooks/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the deletion of a Webhook by id
     * @summary Deletes a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("deleteWebhook", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("deleteWebhook", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("deleteWebhook", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteWebhook", "id", id);
      const localVarPath = `/api/v1/webhooks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a Webhook by id
     * @summary Shows a Webhook for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editWebhook: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("editWebhook", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("editWebhook", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("editWebhook", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("editWebhook", "id", id);
      const localVarPath = `/api/v1/webhooks/{id}/edit`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists Webhooks, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the Webhooks, these are handled by the WebhookFilters class which defines the methods available
     * @summary Gets a list of Webhooks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getWebhooks", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getWebhooks", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getWebhooks", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (index !== undefined) {
        localVarQueryParameter["index"] = index;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Webhook object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooksCreate: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("getWebhooksCreate", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("getWebhooksCreate", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("getWebhooksCreate", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/webhooks/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Displays a Webhook by id
     * @summary Shows a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showWebhook: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("showWebhook", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("showWebhook", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("showWebhook", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("showWebhook", "id", id);
      const localVarPath = `/api/v1/webhooks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds an Webhook to a company
     * @summary Adds a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeWebhook: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("storeWebhook", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("storeWebhook", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("storeWebhook", "xRequestedWith", xRequestedWith);
      const localVarPath = `/api/v1/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Handles the updating of a Webhook by id
     * @summary Updates a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook: async (
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'xApiSecret' is not null or undefined
      assertParamExists("updateWebhook", "xApiSecret", xApiSecret);
      // verify required parameter 'xApiToken' is not null or undefined
      assertParamExists("updateWebhook", "xApiToken", xApiToken);
      // verify required parameter 'xRequestedWith' is not null or undefined
      assertParamExists("updateWebhook", "xRequestedWith", xRequestedWith);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("updateWebhook", "id", id);
      const localVarPath = `/api/v1/webhooks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (xApiSecret !== undefined && xApiSecret !== null) {
        localVarHeaderParameter["X-Api-Secret"] = String(xApiSecret);
      }

      if (xApiToken !== undefined && xApiToken !== null) {
        localVarHeaderParameter["X-Api-Token"] = String(xApiToken);
      }

      if (xRequestedWith !== undefined && xRequestedWith !== null) {
        localVarHeaderParameter["X-Requested-With"] = String(xRequestedWith);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of Webhooks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkWebhooks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkWebhooks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the deletion of a Webhook by id
     * @summary Deletes a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a Webhook by id
     * @summary Shows a Webhook for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Lists Webhooks, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the Webhooks, these are handled by the WebhookFilters class which defines the methods available
     * @summary Gets a list of Webhooks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhooks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Webhook object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhooksCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWebhooksCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Displays a Webhook by id
     * @summary Shows a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async showWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.showWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Adds an Webhook to a company
     * @summary Adds a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Handles the updating of a Webhook by id
     * @summary Updates a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhooksApiFp(configuration);
  return {
    /**
     *
     * @summary Performs bulk actions on an array of Webhooks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {Array<number>} requestBody User credentials
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkWebhooks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      requestBody: Array<number>,
      index?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .bulkWebhooks(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          requestBody,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the deletion of a Webhook by id
     * @summary Deletes a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteWebhook(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a Webhook by id
     * @summary Shows a Webhook for editting
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .editWebhook(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists Webhooks, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the Webhooks, these are handled by the WebhookFilters class which defines the methods available
     * @summary Gets a list of Webhooks
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {string} [index] Replaces the default response index from data to a user specific string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooks(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      index?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .getWebhooks(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          index,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a blank object with default values
     * @summary Gets a new blank Webhook object
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhooksCreate(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .getWebhooksCreate(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Displays a Webhook by id
     * @summary Shows a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    showWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .showWebhook(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds an Webhook to a company
     * @summary Adds a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      include?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .storeWebhook(xApiSecret, xApiToken, xRequestedWith, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Handles the updating of a Webhook by id
     * @summary Updates a Webhook
     * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
     * @param {string} xApiToken The API token to be used for authentication
     * @param {string} xRequestedWith Used to send the XMLHttpRequest header
     * @param {string} id The Webhook Hashed ID
     * @param {string} [include] Includes child relationships in the response, format is comma separated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(
      xApiSecret: string,
      xApiToken: string,
      xRequestedWith: string,
      id: string,
      include?: string,
      options?: any
    ): AxiosPromise<Webhook> {
      return localVarFp
        .updateWebhook(
          xApiSecret,
          xApiToken,
          xRequestedWith,
          id,
          include,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
  /**
   *
   * @summary Performs bulk actions on an array of Webhooks
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {Array<number>} requestBody User credentials
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public bulkWebhooks(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    requestBody: Array<number>,
    index?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .bulkWebhooks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        requestBody,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the deletion of a Webhook by id
   * @summary Deletes a Webhook
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Webhook Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public deleteWebhook(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .deleteWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a Webhook by id
   * @summary Shows a Webhook for editting
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Webhook Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public editWebhook(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .editWebhook(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Lists Webhooks, search and filters allow fine grained lists to be generated.      *      *      Query parameters can be added to performed more fine grained filtering of the Webhooks, these are handled by the WebhookFilters class which defines the methods available
   * @summary Gets a list of Webhooks
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {string} [index] Replaces the default response index from data to a user specific string
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public getWebhooks(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    index?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .getWebhooks(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        index,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a blank object with default values
   * @summary Gets a new blank Webhook object
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public getWebhooksCreate(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .getWebhooksCreate(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Displays a Webhook by id
   * @summary Shows a Webhook
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Webhook Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public showWebhook(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .showWebhook(xApiSecret, xApiToken, xRequestedWith, id, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds an Webhook to a company
   * @summary Adds a Webhook
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public storeWebhook(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    include?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .storeWebhook(xApiSecret, xApiToken, xRequestedWith, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Handles the updating of a Webhook by id
   * @summary Updates a Webhook
   * @param {string} xApiSecret The API secret as defined by the .env variable API_SECRET
   * @param {string} xApiToken The API token to be used for authentication
   * @param {string} xRequestedWith Used to send the XMLHttpRequest header
   * @param {string} id The Webhook Hashed ID
   * @param {string} [include] Includes child relationships in the response, format is comma separated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public updateWebhook(
    xApiSecret: string,
    xApiToken: string,
    xRequestedWith: string,
    id: string,
    include?: string,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .updateWebhook(
        xApiSecret,
        xApiToken,
        xRequestedWith,
        id,
        include,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
